{"version":3,"file":"form-atoms.dev.js","sources":["../../node_modules/jotai/esm/index.js","../../node_modules/jotai/esm/utils.js","../../src/utils.ts","../../src/index.tsx"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(\n            () => writeGetter(a, options)\n          );\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n","import { atom, SECRET_INTERNAL_getScopeContext, useAtom, useSetAtom } from 'jotai';\nexport { useAtomValue, useSetAtom as useUpdateAtom } from 'jotai';\nimport { useContext, useCallback, useMemo } from 'react';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(initialValue, (get, set, update) => {\n    if (update === RESET) {\n      set(anAtom, initialValue);\n    } else {\n      set(\n        anAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  });\n  return anAtom;\n}\n\nconst WRITE_ATOM = \"w\";\nconst RESTORE_ATOMS = \"h\";\n\nfunction useResetAtom(anAtom, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const store = useContext(ScopeContext).s;\n  const setAtom = useCallback(\n    () => store[WRITE_ATOM](anAtom, RESET),\n    [store, anAtom]\n  );\n  return setAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, scope) {\n  const [state, setState] = useAtom(anAtom, scope);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        atoms.delete(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getWeakCacheItem = (cache, deps) => {\n  do {\n    const [dep, ...rest] = deps;\n    const entry = cache.get(dep);\n    if (!entry) {\n      return;\n    }\n    if (!rest.length) {\n      return entry[1];\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst setWeakCacheItem = (cache, deps, item) => {\n  do {\n    const [dep, ...rest] = deps;\n    let entry = cache.get(dep);\n    if (!entry) {\n      entry = [ new WeakMap()];\n      cache.set(dep, entry);\n    }\n    if (!rest.length) {\n      entry[1] = item;\n      return;\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst createMemoizeAtom = () => {\n  const cache = /* @__PURE__ */ new WeakMap();\n  const memoizeAtom = (createAtom, deps) => {\n    const cachedAtom = getWeakCacheItem(cache, deps);\n    if (cachedAtom) {\n      return cachedAtom;\n    }\n    const createdAtom = createAtom();\n    setWeakCacheItem(cache, deps, createdAtom);\n    return createdAtom;\n  };\n  return memoizeAtom;\n};\n\nconst memoizeAtom$4 = createMemoizeAtom();\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memoizeAtom$4(() => {\n    const refAtom = atom(() => ({}));\n    const derivedAtom = atom((get) => {\n      const slice = selector(get(anAtom));\n      const ref = get(refAtom);\n      if (\"prev\" in ref && equalityFn(ref.prev, slice)) {\n        return ref.prev;\n      }\n      ref.prev = slice;\n      return slice;\n    });\n    return derivedAtom;\n  }, [anAtom, selector, equalityFn]);\n}\n\nfunction useAtomCallback(callback, scope) {\n  const anAtom = useMemo(\n    () => atom(\n      null,\n      (get, set, [arg, resolve, reject]) => {\n        try {\n          resolve(callback(get, set, arg));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    ),\n    [callback]\n  );\n  const invoke = useSetAtom(anAtom, scope);\n  return useCallback(\n    (arg) => {\n      let isSync = true;\n      let settled = {};\n      const promise = new Promise((resolve, reject) => {\n        invoke([\n          arg,\n          (v) => {\n            if (isSync) {\n              settled = { v };\n            } else {\n              resolve(v);\n            }\n          },\n          (e) => {\n            if (isSync) {\n              settled = { e };\n            } else {\n              reject(e);\n            }\n          }\n        ]);\n      });\n      isSync = false;\n      if (\"e\" in settled) {\n        throw settled.e;\n      }\n      if (\"v\" in settled) {\n        return settled.v;\n      }\n      return promise;\n    },\n    [invoke]\n  );\n}\n\nconst memoizeAtom$3 = createMemoizeAtom();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memoizeAtom$3(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, [anAtom]);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get) => deepFreeze(origRead(get));\n    return anAtom;\n  };\n}\n\nconst memoizeAtom$2 = createMemoizeAtom();\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memoizeAtom$2(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read2 = (get) => {\n            const ref = get(refAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write2 = (get, set, update) => {\n            const ref = get(refAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            set(arrAtom, [\n              ...arr2.slice(0, index2),\n              nextItem,\n              ...arr2.slice(index2 + 1)\n            ]);\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read2, write2) : atom(read2);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const refAtom = atom(() => ({}));\n      const read = (get) => {\n        const ref = get(refAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, ref.prev);\n        ref.prev = arr;\n        return mapping.atomList;\n      };\n      const write = (get, set, action) => {\n        if (\"read\" in action) {\n          console.warn(\"atomToRemove is deprecated. use action with type\");\n          action = { type: \"remove\", atom: action };\n        }\n        switch (action.type) {\n          case \"remove\": {\n            const index = get(splittedAtom).indexOf(action.atom);\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                ...arr.slice(index + 1)\n              ]);\n            }\n            break;\n          }\n          case \"insert\": {\n            const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                action.value,\n                ...arr.slice(index)\n              ]);\n            }\n            break;\n          }\n          case \"move\": {\n            const index1 = get(splittedAtom).indexOf(action.atom);\n            const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index1 >= 0 && index2 >= 0) {\n              const arr = get(arrAtom);\n              if (index1 < index2) {\n                set(arrAtom, [\n                  ...arr.slice(0, index1),\n                  ...arr.slice(index1 + 1, index2),\n                  arr[index1],\n                  ...arr.slice(index2)\n                ]);\n              } else {\n                set(arrAtom, [\n                  ...arr.slice(0, index2),\n                  arr[index1],\n                  ...arr.slice(index2, index1),\n                  ...arr.slice(index1 + 1)\n                ]);\n              }\n            }\n            break;\n          }\n        }\n      };\n      const splittedAtom = isWritable(arrAtom) ? atom(read, write) : atom(read);\n      return splittedAtom;\n    },\n    keyExtractor ? [arrAtom, keyExtractor] : [arrAtom]\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  const anAtom = atom(\n    (get) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        return set(overwrittenAtom, EMPTY);\n      }\n      return set(\n        overwrittenAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  );\n  return anAtom;\n}\n\nconst memoizeAtom$1 = createMemoizeAtom();\nconst emptyArrayAtom = atom(() => []);\nfunction waitForAll(atoms) {\n  const createAtom = () => {\n    const unwrappedAtoms = unwrapAtoms(atoms);\n    const derivedAtom = atom((get) => {\n      const promises = [];\n      const values = unwrappedAtoms.map((anAtom, index) => {\n        try {\n          return get(anAtom);\n        } catch (e) {\n          if (e instanceof Promise) {\n            promises[index] = e;\n          } else {\n            throw e;\n          }\n        }\n      });\n      if (promises.length) {\n        throw Promise.all(promises);\n      }\n      return wrapResults(atoms, values);\n    });\n    return derivedAtom;\n  };\n  if (Array.isArray(atoms)) {\n    if (atoms.length) {\n      return memoizeAtom$1(createAtom, atoms);\n    }\n    return emptyArrayAtom;\n  }\n  return createAtom();\n}\nconst unwrapAtoms = (atoms) => Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map((key) => atoms[key]);\nconst wrapResults = (atoms, results) => Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce(\n  (out, key, idx) => ({ ...out, [key]: results[idx] }),\n  {}\n);\n\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  return {\n    getItem: (key) => {\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          lastValue = JSON.parse(str2);\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = getStringStorage().getItem(key);\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => getStringStorage().setItem(key, JSON.stringify(newValue)),\n    removeItem: (key) => getStringStorage().removeItem(key)\n  };\n}\nconst defaultStorage = createJSONStorage(() => localStorage);\ndefaultStorage.subscribe = (key, callback) => {\n  const storageEventCallback = (e) => {\n    if (e.key === key && e.newValue) {\n      callback(JSON.parse(e.newValue));\n    }\n  };\n  window.addEventListener(\"storage\", storageEventCallback);\n  return () => {\n    window.removeEventListener(\"storage\", storageEventCallback);\n  };\n};\nfunction atomWithStorage(key, initialValue, storage = defaultStorage) {\n  const getInitialValue = () => {\n    try {\n      const value = storage.getItem(key);\n      if (value instanceof Promise) {\n        return value.catch(() => initialValue);\n      }\n      return value;\n    } catch {\n      return initialValue;\n    }\n  };\n  const baseAtom = atom(storage.delayInit ? initialValue : getInitialValue());\n  baseAtom.onMount = (setAtom) => {\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom);\n      setAtom(getInitialValue());\n    }\n    if (storage.delayInit) {\n      const value = getInitialValue();\n      if (value instanceof Promise) {\n        value.then(setAtom);\n      } else {\n        setAtom(value);\n      }\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      if (update === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      const newValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      set(baseAtom, newValue);\n      return storage.setItem(key, newValue);\n    }\n  );\n  return anAtom;\n}\nfunction atomWithHash(key, initialValue, options) {\n  const serialize = (options == null ? void 0 : options.serialize) || JSON.stringify;\n  const deserialize = (options == null ? void 0 : options.deserialize) || JSON.parse;\n  const subscribe = (options == null ? void 0 : options.subscribe) || ((callback) => {\n    window.addEventListener(\"hashchange\", callback);\n    return () => {\n      window.removeEventListener(\"hashchange\", callback);\n    };\n  });\n  const hashStorage = {\n    getItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      const storedValue = searchParams.get(key2);\n      if (storedValue === null) {\n        throw new Error(\"no value stored\");\n      }\n      return deserialize(storedValue);\n    },\n    setItem: (key2, newValue) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.set(key2, serialize(newValue));\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(null, \"\", \"#\" + searchParams.toString());\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    removeItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.delete(key2);\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(null, \"\", \"#\" + searchParams.toString());\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    ...(options == null ? void 0 : options.delayInit) && { delayInit: true },\n    subscribe: (key2, setValue) => {\n      const callback = () => {\n        const searchParams = new URLSearchParams(location.hash.slice(1));\n        const str = searchParams.get(key2);\n        if (str !== null) {\n          setValue(deserialize(str));\n        } else {\n          setValue(initialValue);\n        }\n      };\n      return subscribe(callback);\n    }\n  };\n  return atomWithStorage(key, initialValue, hashStorage);\n}\n\nfunction atomWithObservable(createObservable, options) {\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = createObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    const EMPTY = Symbol();\n    let resolveEmittedInitialValue = null;\n    let initialEmittedValue = (options == null ? void 0 : options.initialValue) === void 0 ? new Promise((resolve) => {\n      resolveEmittedInitialValue = resolve;\n    }) : void 0;\n    let initialValueWasEmitted = false;\n    let emittedValueBeforeMount = EMPTY;\n    let isSync = true;\n    let setData = (data) => {\n      if ((options == null ? void 0 : options.initialValue) === void 0 && !initialValueWasEmitted) {\n        if (isSync) {\n          initialEmittedValue = data;\n        }\n        resolveEmittedInitialValue == null ? void 0 : resolveEmittedInitialValue(data);\n        initialValueWasEmitted = true;\n        resolveEmittedInitialValue = null;\n      } else {\n        emittedValueBeforeMount = data;\n      }\n    };\n    const dataListener = (data) => {\n      setData(data);\n    };\n    const errorListener = (error) => {\n      setData(Promise.reject(error));\n    };\n    let subscription = null;\n    let initialValue;\n    if ((options == null ? void 0 : options.initialValue) !== void 0) {\n      initialValue = getInitialValue(options);\n    } else {\n      subscription = observable.subscribe(dataListener, errorListener);\n      initialValue = initialEmittedValue;\n    }\n    isSync = false;\n    const dataAtom = atom(initialValue);\n    dataAtom.onMount = (update) => {\n      setData = update;\n      if (emittedValueBeforeMount !== EMPTY) {\n        update(emittedValueBeforeMount);\n      }\n      if (!subscription) {\n        subscription = observable.subscribe(dataListener, errorListener);\n      }\n      return () => {\n        subscription == null ? void 0 : subscription.unsubscribe();\n        subscription = null;\n      };\n    };\n    return { dataAtom, observable };\n  });\n  const observableAtom = atom(\n    (get) => {\n      const { dataAtom } = get(observableResultAtom);\n      return get(dataAtom);\n    },\n    (get, set, data) => {\n      const { dataAtom, observable } = get(observableResultAtom);\n      if (\"next\" in observable) {\n        let subscription = null;\n        const callback = (data2) => {\n          set(dataAtom, data2);\n          subscription == null ? void 0 : subscription.unsubscribe();\n        };\n        subscription = observable.subscribe(callback);\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\nfunction getInitialValue(options) {\n  const initialValue = options.initialValue;\n  return initialValue instanceof Function ? initialValue() : initialValue;\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const store = scopeContainer.s;\n  const hydratedSet = getHydratedSet(scopeContainer);\n  const tuplesToRestore = [];\n  for (const tuple of values) {\n    const atom = tuple[0];\n    if (!hydratedSet.has(atom)) {\n      hydratedSet.add(atom);\n      tuplesToRestore.push(tuple);\n    }\n  }\n  if (tuplesToRestore.length) {\n    store[RESTORE_ATOMS](tuplesToRestore);\n  }\n}\nfunction getHydratedSet(scopeContainer) {\n  let hydratedSet = hydratedMap.get(scopeContainer);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(scopeContainer, hydratedSet);\n  }\n  return hydratedSet;\n}\n\nconst memoizeAtom = createMemoizeAtom();\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memoizeAtom(() => {\n    const loadableAtomCache = /* @__PURE__ */ new WeakMap();\n    const catchAtom = atom((get) => {\n      let promise;\n      try {\n        const data = get(anAtom);\n        const loadableAtom2 = atom({ state: \"hasData\", data });\n        return loadableAtom2;\n      } catch (error) {\n        if (error instanceof Promise) {\n          promise = error;\n        } else {\n          const loadableAtom2 = atom({\n            state: \"hasError\",\n            error\n          });\n          return loadableAtom2;\n        }\n      }\n      const cached = loadableAtomCache.get(promise);\n      if (cached) {\n        return cached;\n      }\n      const loadableAtom = atom(\n        LOADING,\n        async (get2, set) => {\n          try {\n            const data = await get2(anAtom, { unstable_promise: true });\n            set(loadableAtom, { state: \"hasData\", data });\n          } catch (error) {\n            set(loadableAtom, { state: \"hasError\", error });\n          }\n        }\n      );\n      loadableAtom.onMount = (init) => {\n        init();\n      };\n      loadableAtomCache.set(promise, loadableAtom);\n      return loadableAtom;\n    });\n    const derivedAtom = atom((get) => {\n      const loadableAtom = get(catchAtom);\n      return get(loadableAtom);\n    });\n    return derivedAtom;\n  }, [anAtom]);\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithHash, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom, waitForAll };\n","export function setPath(target: any, paths: string[], value: unknown) {\n  if (paths.length === 1) {\n    target[paths[0]] = value;\n    return target;\n  }\n\n  let next = target;\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (i === paths.length - 1) {\n      next[path] = value;\n    } else {\n      const current = next[path];\n      next = next[path] = current ?? (isNaN(paths[i + 1] as any) ? {} : []);\n    }\n  }\n}\n","import type {\n  Atom,\n  ExtractAtomUpdate,\n  ExtractAtomValue,\n  Getter,\n  Setter,\n  WritableAtom,\n} from \"jotai\";\nimport { atom, Provider, useAtom, useAtomValue, useSetAtom } from \"jotai\";\nimport { atomWithReset, RESET, useHydrateAtoms } from \"jotai/utils\";\nimport * as React from \"react\";\nimport { setPath } from \"./utils\";\n\n//\n// Components\n//\n\n/**\n * A React component that renders form atoms and their fields in an isolated\n * scope using a Jotai Provider.\n *\n * @param {FormProps<Fields>} props - Component props\n */\nexport function Form<Fields extends FormAtomFields>(props: FormProps<Fields>) {\n  const { scope, ...atomProps } = props;\n  return (\n    <Provider scope={scope}>\n      <FormAtom {...atomProps} />\n    </Provider>\n  );\n}\n\nfunction FormAtom<Fields extends FormAtomFields>(\n  props:\n    | {\n        atom: FormAtom<Fields>;\n        render(props: UseFormAtom<Fields>): JSX.Element;\n      }\n    | {\n        atom: FormAtom<Fields>;\n        component: React.ComponentType<UseFormAtom<Fields>>;\n      }\n) {\n  const form = useFormAtom(props.atom);\n\n  if (\"render\" in props) {\n    return props.render(form);\n  }\n\n  return <props.component {...form} />;\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that are rendered as native HTML elements because\n * the props can unpack directly into the underlying component.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function InputField<Value extends string | number | string[]>(\n  props: InputFieldProps<Value>\n) {\n  const fieldAtom = useFieldAtom(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtom.props, fieldAtom.state, fieldAtom.actions);\n  }\n\n  return React.createElement(props.component, fieldAtom.props);\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that aren't rendered as native HTML elements.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function Field<Value>(props: FieldProps<Value>) {\n  const fieldAtomState = useFieldAtomState(props.atom, props.scope);\n  const fieldAtomStateActions = useFieldAtomActions(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtomState, fieldAtomStateActions);\n  }\n\n  return (\n    <props.component state={fieldAtomState} actions={fieldAtomStateActions} />\n  );\n}\n\n//\n// Forms\n//\n\n/**\n * An atom that derives its state fields atoms and allows you to submit,\n * validate, and reset your form.\n *\n * @param {FormAtomFields} fields - An object containing field atoms to\n *   be included in the form. Field atoms can be deeply nested in\n *   objects and arrays.\n * @returns The `formAtom` function returns a Jotai `Atom`\n *   comprised of other atoms for managing the state of the form.\n */\nexport function formAtom<Fields extends FormAtomFields>(\n  fields: Fields\n): FormAtom<Fields> {\n  const fieldsAtom = atomWithReset(fields);\n  const valuesAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const values = {} as FormAtomValues<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(values, path, get(fieldAtom.value));\n    });\n\n    return values;\n  });\n\n  async function validateFields(\n    get: Getter,\n    set: Setter,\n    event: FieldAtomValidateOn\n  ) {\n    const fields = get(fieldsAtom);\n    const promises: Promise<boolean>[] = [];\n\n    walkFields(fields, (nextField) => {\n      async function validate(field: typeof nextField) {\n        const fieldAtom = get(field);\n        const value = get(fieldAtom.value);\n        const dirty = get(fieldAtom.dirty);\n        // This pointer prevents a stale validation result from being\n        // set after the most recent validation has been performed.\n        const ptr = get(fieldAtom._validateCount) + 1;\n        set(fieldAtom._validateCount, ptr);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(fieldAtom.touched, true);\n        }\n\n        const maybePromise = fieldAtom._validateCallback?.({\n          get,\n          value,\n          dirty,\n          touched: get(fieldAtom.touched),\n          event,\n        });\n\n        let errors: string[];\n\n        if (isPromise(maybePromise)) {\n          set(fieldAtom.validateStatus, \"validating\");\n          errors = (await maybePromise) ?? get(fieldAtom.errors);\n        } else {\n          errors = maybePromise ?? get(fieldAtom.errors);\n        }\n\n        if (ptr === get(fieldAtom._validateCount)) {\n          set(fieldAtom.errors, errors);\n          set(\n            fieldAtom.validateStatus,\n            errors.length > 0 ? \"invalid\" : \"valid\"\n          );\n        }\n\n        if (errors && errors.length) {\n          return false;\n        }\n\n        return true;\n      }\n\n      promises.push(validate(nextField));\n    });\n\n    await Promise.all(promises);\n  }\n\n  const validateResultAtom = atom<FormAtomValidateStatus>((get) => {\n    const fields = get(fieldsAtom);\n    let status: FormAtomValidateStatus = \"valid\";\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      const fieldStatus = get(fieldAtom.validateStatus);\n\n      if (fieldStatus === \"validating\") {\n        status = \"validating\";\n        return false;\n      } else if (fieldStatus === \"invalid\") {\n        status = \"invalid\";\n        return false;\n      }\n    });\n\n    return status;\n  });\n\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      event && validateFields(get, set, event);\n    }\n  );\n\n  const errorsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const errors = {} as FormAtomErrors<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(errors, path, get(fieldAtom.errors));\n    });\n\n    return errors;\n  });\n\n  const submitCountAtom = atom(0);\n  const submitStatusCountAtom = atom(0);\n  const submitResultAtom = atom<FormAtomSubmitStatus>(\"idle\");\n  const submitAtom = atom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >(null, (get, set, onSubmit) => {\n    async function resolveSubmit() {\n      // This pointer prevents a stale validation result from being\n      // set after the most recent validation has been performed.\n      const ptr = get(submitStatusCountAtom) + 1;\n      set(submitStatusCountAtom, ptr);\n      set(submitCountAtom, (count) => ++count);\n      await validateFields(get, set, \"submit\");\n      const validateStatus = get(validateResultAtom);\n\n      if (validateStatus === \"invalid\") {\n        return (\n          ptr === get(submitStatusCountAtom) && set(submitResultAtom, \"idle\")\n        );\n      }\n\n      const submission = onSubmit(get(valuesAtom));\n\n      try {\n        if (isPromise(submission)) {\n          ptr === get(submitStatusCountAtom) &&\n            set(submitResultAtom, \"submitting\");\n          await submission;\n        }\n        // eslint-disable-next-line no-empty\n      } catch (err) {\n      } finally {\n        if (ptr === get(submitStatusCountAtom)) {\n          set(submitResultAtom, \"submitted\");\n        }\n      }\n    }\n\n    resolveSubmit();\n  });\n\n  const dirtyAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    let dirty = false;\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      dirty = get(fieldAtom.dirty);\n      if (dirty) return false;\n    });\n\n    return dirty;\n  });\n\n  const touchedFieldsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const touchedFields = {} as FormAtomTouchedFields<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(touchedFields, path, get(fieldAtom.touched));\n    });\n\n    return touchedFields;\n  });\n\n  const resetAtom = atom(null, (get, set) => {\n    const fields = get(fieldsAtom);\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      set(fieldAtom.reset);\n    });\n\n    set(submitStatusCountAtom, (current) => ++current);\n    set(submitResultAtom, \"idle\");\n  });\n\n  return atom({\n    fields: fieldsAtom,\n    values: valuesAtom,\n    errors: errorsAtom,\n    dirty: dirtyAtom,\n    touchedFields: touchedFieldsAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    submit: submitAtom,\n    submitStatus: submitResultAtom,\n    submitCount: submitCountAtom,\n    reset: resetAtom,\n  });\n}\n\n/**\n * A hook that returns an object that contains the `fieldAtoms` and actions to\n * validate, submit, and reset the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of functions that can be used to interact\n *   with the form.\n */\nexport function useFormAtom<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): UseFormAtom<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      reset,\n      submit(onSubmit) {\n        return (e) => {\n          e?.preventDefault();\n          startTransition(() => {\n            handleSubmit(onSubmit);\n          });\n        };\n      },\n    }),\n    [fieldAtoms, validate, reset, handleSubmit]\n  );\n}\n\n/**\n * A hook that returns the primary state of the form atom including values, errors,\n * submit and validation status, as well as the `fieldAtoms`. Note that this\n * hook will cuase its parent component to re-render any time those states\n * change, so it can be useful to use more targeted state hooks like\n * `useFormAtomStatus`.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomState<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomState<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const submitCount = useAtomValue(form.submitCount, scope);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n  const values = useAtomValue(form.values, scope);\n  const errors = useAtomValue(form.errors, scope);\n  const dirty = useAtomValue(form.dirty, scope);\n  const touchedFields = useAtomValue(form.touchedFields, scope);\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      values: values as any,\n      errors: errors as any,\n      dirty,\n      touchedFields: touchedFields as any,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    }),\n    [\n      fieldAtoms,\n      values,\n      errors,\n      dirty,\n      touchedFields,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    ]\n  );\n}\n\n/**\n * A hook that returns a set of actions that can be used to update the state\n * of the form atom. This includes updating fields, submitting, resetting,\n * and validating the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomActions<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomActions<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const updateFields = useSetAtom(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const submit = React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        handleSubmit(values);\n      },\n    [handleSubmit]\n  );\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      updateFields,\n      reset,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      submit,\n    }),\n    [updateFields, reset, validate, submit]\n  );\n}\n\n/**\n * A hook that returns the errors of the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form data.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the form.\n */\nexport function useFormAtomErrors<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.errors, scope);\n}\n\n/**\n * A hook that returns the values of the form atom\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The values of the form.\n */\nexport function useFormAtomValues<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.values, scope);\n}\n\n/**\n * A hook that returns the `submitStatus` and `validateStatus` of\n * the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns An object containing the `submitStatus` and\n *   `validateStatus` of the form\n */\nexport function useFormAtomStatus<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomStatus {\n  const form = useAtomValue(formAtom);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n\n  return React.useMemo(\n    () => ({ submitStatus, validateStatus }),\n    [submitStatus, validateStatus]\n  );\n}\n\n/**\n * A hook that returns a callback for handling form submission.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A callback for handling form submission. The callback\n *   takes the form values as an argument and returs an additional callback\n *   that invokes `event.preventDefault()` if it receives an event as its argument.\n */\nexport function useFormAtomSubmit<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const [, startTransition] = useTransition();\n  const form = useAtomValue(formAtom, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  return React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        startTransition(() => {\n          handleSubmit(values);\n        });\n      },\n    [handleSubmit]\n  );\n}\n\n//\n// Fields\n//\n\n/**\n * An atom that represents a field in a form. It manages state for the field,\n * including the name, value, errors, dirty, validation, and touched state.\n *\n * @param {FieldAtomConfig<Value>} config - The initial state and configuration of the field.\n * @returns A FieldAtom.\n */\nexport function fieldAtom<Value>(\n  config: FieldAtomConfig<Value>\n): FieldAtom<Value> {\n  const nameAtom = atomWithReset(config.name);\n  const valueAtom = atomWithReset<Value>(config.value);\n  const touchedAtom = atomWithReset(config.touched ?? false);\n  const dirtyAtom = atom((get) => {\n    return get(valueAtom) !== config.value;\n  });\n  const errorsAtom = atom<string[]>([]);\n\n  const validateCountAtom = atom(0);\n  const validateResultAtom = atom<FormAtomValidateStatus>(\"valid\");\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      async function resolveErrors() {\n        if (!event) return;\n        // This pointer prevents a stale validation result from being\n        // set to state after the most recent invocation of validate.\n        const ptr = get(validateCountAtom) + 1;\n        set(validateCountAtom, ptr);\n        const dirty = get(dirtyAtom);\n        const value = get(valueAtom);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(touchedAtom, true);\n        }\n\n        let errors: string[] = [];\n\n        const maybeValidatePromise = config.validate?.({\n          get,\n          dirty,\n          touched: get(touchedAtom),\n          value,\n          event: event,\n        });\n\n        if (isPromise(maybeValidatePromise)) {\n          ptr === get(validateCountAtom) &&\n            set(validateResultAtom, \"validating\");\n          errors = (await maybeValidatePromise) ?? get(errorsAtom);\n        } else {\n          errors = maybeValidatePromise ?? get(errorsAtom);\n        }\n\n        if (ptr === get(validateCountAtom)) {\n          set(errorsAtom, errors);\n          set(validateResultAtom, errors.length > 0 ? \"invalid\" : \"valid\");\n        }\n      }\n\n      resolveErrors();\n    }\n  );\n\n  const refAtom = atom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n  >(null);\n\n  const resetAtom = atom<null, void>(null, (get, set) => {\n    set(errorsAtom, []);\n    set(touchedAtom, RESET);\n    set(valueAtom, RESET);\n    // Need to set a new pointer to prevent stale validation results\n    // from being set to state after this invocation.\n    set(validateCountAtom, (count) => ++count);\n    set(validateResultAtom, \"valid\");\n  });\n\n  return atom({\n    name: nameAtom,\n    value: valueAtom,\n    touched: touchedAtom,\n    dirty: dirtyAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    errors: errorsAtom,\n    reset: resetAtom,\n    ref: refAtom,\n    _validateCallback: config.validate,\n    _validateCount: validateCountAtom,\n  });\n}\n\n/**\n * A hook that returns a set of actions that can be used to interact with the\n * field atom state.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of actions that can be used to interact with the field atom.\n */\nexport function useFieldAtomActions<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomActions<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const setValue = useSetAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const setErrors = useSetAtom(field.errors, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const reset = useSetAtom(field.reset, scope);\n  const ref = useAtomValue(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      setValue(value) {\n        setValue(value);\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n      setTouched(touched) {\n        setTouched(touched);\n\n        if (touched) {\n          startTransition(() => {\n            validate(\"touch\");\n          });\n        }\n      },\n      setErrors,\n      focus() {\n        ref?.focus();\n      },\n      reset,\n    }),\n    [setErrors, reset, validate, setValue, setTouched, ref]\n  );\n}\n\n/**\n * A hook that returns a set of props that can be destructured\n * directly into an `<input>`, `<select>`, or `<textarea>` element.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of props that can be destructured directly into an `<input>`,\n *   `<select>`, or `<textarea>` element.\n */\nexport function useFieldAtomProps<\n  Value\n>(fieldAtom: FieldAtom<Value>, scope?: Scope): FieldAtomProps<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const name = useAtomValue(field.name, scope);\n  const [value, setValue] = useAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const ref = useSetAtom(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      name,\n      value: value as Value,\n      \"aria-invalid\": validateStatus === \"invalid\",\n      ref,\n      onBlur() {\n        setTouched(true);\n        startTransition(() => {\n          validate(\"blur\");\n        });\n      },\n      onChange(event) {\n        // @ts-expect-error\n        setValue(event.target.value);\n\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n    }),\n    [name, value, validateStatus, ref, setTouched, validate, setValue]\n  );\n}\n\n/**\n * A hook that returns the state of a field atom. This includes the field's\n * value, whether it has been touched, whether it is dirty, the validation status,\n * and any errors.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The state of the field atom.\n */\nexport function useFieldAtomState<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomState<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const value = useAtomValue(field.value, scope);\n  const touched = useAtomValue(field.touched, scope);\n  const dirty = useAtomValue(field.dirty, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const errors = useAtomValue(field.errors, scope);\n\n  return React.useMemo(\n    () => ({\n      value: value as unknown as Value,\n      touched,\n      dirty,\n      validateStatus,\n      errors,\n    }),\n    [value, touched, dirty, validateStatus, errors]\n  );\n}\n\n/**\n * A hook that returns the value of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The value of the field atom.\n */\nexport function useFieldAtomValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.value, scope);\n}\n\n/**\n * A hook that returns the errors of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtomErrors<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.errors, scope);\n}\n\n/**\n * Sets the initial value of a field atom. Initial values can only be set once\n * per scope. Therefore, if the initial value used is changed during rerenders,\n * it won't update the atom value.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that you want to use to store the value.\n * @param {Value} initialValue - The initial value of the field.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFieldAtomInitialValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  initialValue?: Value,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  useHydrateAtoms(\n    initialValue === undefined ? [] : [[field.value, initialValue] as const],\n    scope\n  );\n}\n\n/**\n * A hook that returns `props`, `state`, and `actions` of a field atom from\n * `useFieldAtomProps`, `useFieldAtomState`, and `useFieldAtomActions`.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtom<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): UseFieldAtom<Value> {\n  const props = useFieldAtomProps<Value>(fieldAtom, scope);\n  const actions = useFieldAtomActions<Value>(fieldAtom, scope);\n  const state = useFieldAtomState<Value>(fieldAtom, scope);\n  return React.useMemo<UseFieldAtom<Value>>(\n    () => ({ props, actions, state }),\n    [props, actions, state]\n  );\n}\n\nconst useTransition: () => [boolean, typeof React.startTransition] =\n  typeof React.useTransition === \"function\"\n    ? React.useTransition\n    : () => [false, (fn) => fn()];\n\nfunction isPromise(value: any): value is Promise<any> {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n}\n\nfunction isAtom(maybeAtom: any): maybeAtom is FieldAtom<any> {\n  return (\n    maybeAtom !== null &&\n    typeof maybeAtom === \"object\" &&\n    (typeof maybeAtom.read === \"function\" ||\n      typeof maybeAtom.write === \"function\")\n  );\n}\n\n/**\n * A function that walks through an object containing nested field atoms\n * and calls a visitor function for each atom it finds.\n *\n * @param {FormAtomFields} fields - An object containing nested field atoms\n * @param visitor - A function that will be called for each field atom. You can\n *  exit early by returning `false` from the function.\n * @param path - The base path of the field atom.\n */\nexport function walkFields<Fields extends FormAtomFields>(\n  fields: Fields,\n  visitor: (field: FieldAtom<any>, path: string[]) => void | false,\n  path: string[] = []\n) {\n  for (const key in fields) {\n    path.push(key);\n    const field = fields[key];\n\n    if (isAtom(field)) {\n      if (visitor(field, path) === false) return;\n    } else if (Array.isArray(field)) {\n      for (const key in field) {\n        path.push(key);\n        const subField = field[key];\n\n        if (isAtom(subField)) {\n          if (visitor(subField, path) === false) return;\n        } else {\n          walkFields(subField, visitor, path);\n        }\n\n        path.pop();\n      }\n    } else if (typeof field === \"object\") {\n      walkFields(field, visitor, path);\n    }\n\n    path.pop();\n  }\n}\n\nexport { Provider } from \"jotai\";\n\nexport type InputFieldProps<Value extends string | number | string[]> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props that can be directly unpacked into a native HTML input element\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        props: FieldAtomProps<Value>,\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component:\n        | \"input\"\n        | \"textarea\"\n        | \"select\"\n        | React.ComponentType<FieldAtomProps<Value>>;\n    };\n\nexport type FieldProps<Value> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component: React.ComponentType<{\n        state: FieldAtomState<Value>;\n        actions: FieldAtomActions<Value>;\n      }>;\n    };\n\nexport type FormProps<Fields extends FormAtomFields> =\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props returned from a `useFormAtom` hook\n       */\n      render(props: UseFormAtom<Fields>): JSX.Element;\n    }\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component.\n       */\n      component: React.ComponentType<UseFormAtom<Fields>>;\n    };\n\n/**\n * A form submission status\n */\nexport type FormAtomSubmitStatus = \"idle\" | \"submitting\" | \"submitted\";\n/**\n * A form and field validation status\n */\nexport type FormAtomValidateStatus = \"validating\" | \"valid\" | \"invalid\";\n/**\n * Event types that a field atom may validate against\n */\nexport type FieldAtomValidateOn =\n  | \"user\"\n  | \"blur\"\n  | \"change\"\n  | \"touch\"\n  | \"submit\";\n\nexport type FieldAtom<Value> = Atom<{\n  /**\n   * An atom containing the field's name\n   */\n  name: WritableAtom<string | undefined, string | undefined | typeof RESET>;\n  /**\n   * An atom containing the field's value\n   */\n  value: WritableAtom<Value, Value | typeof RESET | ((prev: Value) => Value)>;\n  /**\n   * An atom containing the field's touched status\n   */\n  touched: WritableAtom<\n    boolean,\n    boolean | typeof RESET | ((prev: boolean) => boolean)\n  >;\n  /**\n   * An atom containing the field's dirty status\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A write-only atom for validating the field's value\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * An atom containing the field's validation status\n   */\n  validateStatus: WritableAtom<FormAtomValidateStatus, FormAtomValidateStatus>;\n  /**\n   * An atom containing the field's validation errors\n   */\n  errors: WritableAtom<string[], string[] | ((value: string[]) => string[])>;\n  /**\n   * A write-only atom for resetting the field atoms to their\n   * initial states.\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * An atom containing a reference to the `HTMLElement` the field\n   * is bound to.\n   */\n  ref: WritableAtom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null,\n    | HTMLInputElement\n    | HTMLTextAreaElement\n    | HTMLSelectElement\n    | null\n    | ((\n        value: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n      ) => HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null)\n  >;\n  _validateCount: WritableAtom<number, number | ((current: number) => number)>;\n  _validateCallback?: Validate<Value>;\n}>;\n\nexport type FormAtom<Fields extends FormAtomFields> = Atom<{\n  /**\n   * An atom containing an object of nested field atoms\n   */\n  fields: WritableAtom<\n    Fields,\n    Fields | typeof RESET | ((prev: Fields) => Fields),\n    void\n  >;\n  /**\n   * An read-only atom that derives the form's values from\n   * its nested field atoms.\n   */\n  values: Atom<FormAtomValues<Fields>>;\n  /**\n   * An read-only atom that derives the form's errors from\n   * its nested field atoms.\n   */\n  errors: Atom<FormAtomErrors<Fields>>;\n  /**\n   * A read-only atom that returns `true` if any of the fields in\n   * the form are dirty.\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A read-only atom derives the touched state of its nested field atoms.\n   */\n  touchedFields: Atom<FormAtomTouchedFields<Fields>>;\n  /**\n   * A write-only atom that resets the form's nested field atoms\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * A write-only atom that validates the form's nested field atoms\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * A read-only atom that derives the form's validation status\n   */\n  validateStatus: Atom<FormAtomValidateStatus>;\n  /**\n   * A write-only atom for submitting the form\n   */\n  submit: WritableAtom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >;\n  /**\n   * A read-only atom that reads the number of times the form has\n   * been submitted\n   */\n  submitCount: Atom<number>;\n  /**\n   * An atom that contains the form's submission status\n   */\n  submitStatus: WritableAtom<FormAtomSubmitStatus, FormAtomSubmitStatus>;\n}>;\n\n/**\n * An object containing nested field atoms\n */\nexport type FormAtomFields = {\n  [key: string | number]:\n    | FieldAtom<any>\n    | FormAtomFields\n    | FormAtomFields[]\n    | FieldAtom<any>[];\n};\n\n/**\n * An object containing the values of a form's nested field atoms\n */\nexport type FormAtomValues<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<infer Value>\n    ? Value\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\n/**\n * An object containing the errors of a form's nested field atoms\n */\nexport type FormAtomErrors<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? string[]\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomErrors<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomErrors<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport type FormAtomTouchedFields<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? boolean\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport interface UseFormAtom<Fields extends FormAtomFields> {\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface FormAtomStatus {\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomState<Fields extends FormAtomFields> {\n  /**\n   * An object containing the form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  values: FormAtomValues<Fields>;\n  /**\n   * An object containing the errors of a form's nested field atoms\n   */\n  errors: FormAtomErrors<Fields>;\n  /**\n   * `true` if any of the fields in the form are dirty.\n   */\n  dirty: boolean;\n  /**\n   * An object containing the touched state of the form's nested field atoms.\n   */\n  touchedFields: FormAtomTouchedFields<Fields>;\n  /**\n   * The number of times a form has been submitted\n   */\n  submitCount: number;\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomActions<Fields extends FormAtomFields> {\n  /**\n   * A function for adding/removing fields from the form.\n   *\n   * @param fields - An object containing the form's nested field atoms or\n   *   a callback that receives the current fields and returns the next\n   *   fields.\n   */\n  updateFields(\n    fields: ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"fields\"]>\n  ): void;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface UseFieldAtom<Value> {\n  /**\n   * `<input>`, `<select>`, or `<textarea>` props for the field\n   */\n  props: FieldAtomProps<Value>;\n  /**\n   * Actions for managing the state of the field\n   */\n  actions: FieldAtomActions<Value>;\n  /**\n   * The current state of the field\n   */\n  state: FieldAtomState<Value>;\n}\n\nexport interface FieldAtomProps<Value> {\n  /**\n   * The name of the field if there is one\n   */\n  name: string | undefined;\n  /**\n   * The value of the field\n   */\n  value: Value;\n  /**\n   * A WAI-ARIA property that tells a screen reader whether the\n   * field is invalid\n   */\n  \"aria-invalid\": boolean;\n  /**\n   * A React callback ref that is used to bind the field atom to\n   * an `<input>`, `<select>`, or `<textarea>` element so that it\n   * can be read and focused.\n   */\n  ref: React.RefCallback<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n  >;\n  onBlur(event: React.FormEvent<HTMLInputElement>): void;\n  onBlur(event: React.FormEvent<HTMLTextAreaElement>): void;\n  onBlur(event: React.FormEvent<HTMLSelectElement>): void;\n  onChange(event: React.ChangeEvent<HTMLInputElement>): void;\n  onChange(event: React.ChangeEvent<HTMLTextAreaElement>): void;\n  onChange(event: React.ChangeEvent<HTMLSelectElement>): void;\n}\n\nexport interface FieldAtomActions<Value> {\n  /**\n   * A function that validates the field's value with a `\"user\"` validation\n   * event.\n   */\n  validate(): void;\n  /**\n   * A function for changing the value of a field. This will trigger a `\"change\"`\n   * validation event.\n   *\n   * @param {Value} value - The new value of the field\n   */\n  setValue(\n    value: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>\n  ): void;\n  /**\n   * A function for changing the touched state of a field. This will trigger a\n   * `\"touch\"` validation event.\n   *\n   * @param {boolean} touched - The new touched state of the field\n   */\n  setTouched(\n    touched: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>\n  ): void;\n  /**\n   * A function for changing the error state of a field\n   *\n   * @param {string[]} errors - The new error state of the field\n   */\n  setErrors(\n    errors: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>\n  ): void;\n  /**\n   * Focuses the field atom's `<input>`, `<select>`, or `<textarea>` element\n   * if there is one bound to it.\n   */\n  focus(): void;\n  /**\n   * Resets the field atom to its initial state.\n   */\n  reset(): void;\n}\n\nexport interface FieldAtomState<Value> {\n  /**\n   * The value of the field\n   */\n  value: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>;\n  /**\n   * The touched state of the field\n   */\n  touched: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>;\n  /**\n   * The dirty state of the field. A field is \"dirty\" if it's value has\n   * been changed.\n   */\n  dirty: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"dirty\"]>;\n  /**\n   * The validation status of the field\n   */\n  validateStatus: ExtractAtomValue<\n    ExtractAtomValue<FieldAtom<Value>>[\"validateStatus\"]\n  >;\n  /**\n   * The error state of the field\n   */\n  errors: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>;\n}\n\nexport interface FieldAtomConfig<Value> {\n  /**\n   * Optionally provide a name for the field that will be added\n   * to any attached `<input>`, `<select>`, or `<textarea>` elements\n   */\n  name?: string;\n  /**\n   * The initial value of the field\n   */\n  value: Value;\n  /**\n   * The initial touched state of the field\n   */\n  touched?: boolean;\n  /**\n   * A function that validates the value of the field any time\n   * one of its atoms changes. It must either return an array of\n   * string error messages or undefined. If it returns undefined,\n   * the validation is \"skipped\" and the current errors in state\n   * are retained.\n   */\n  validate?: (state: {\n    /**\n     * A Jotai getter that can read other atoms\n     */\n    get: Getter;\n    /**\n     * The current value of the field\n     */\n    value: Value;\n    /**\n     * The dirty state of the field\n     */\n    dirty: boolean;\n    /**\n     * The touched state of the field\n     */\n    touched: boolean;\n    /**\n     * The event that caused the validation. Either:\n     *\n     * - `\"change\"` - The value of the field has changed\n     * - `\"touch\"` - The field has been touched\n     * - `\"blur\"` - The field has been blurred\n     * - `\"submit\"` - The form has been submitted\n     * - `\"user\"` - A user/developer has triggered the validation\n     */\n    event: FieldAtomValidateOn;\n  }) => void | string[] | Promise<void | string[]>;\n}\n\n/**\n * A utility type for easily typing validate functions\n */\nexport type Validate<Value> = FieldAtomConfig<Value>[\"validate\"];\n\n/**\n * A utility type for easily typing validate function configurations\n */\nexport type ValidateConfig<Value> = Parameters<\n  Exclude<FieldAtomConfig<Value>[\"validate\"], undefined>\n>[0];\n\n/**\n * A `Provider` or `useAtom` hook accepts an optional prop scope which you\n * can use for scoped Provider. When using atoms with a scope, the provider\n * with the same scope will be used. The recommendation for the scope value\n * is a unique symbol. The primary use case of scope is for library usage.\n */\nexport type Scope = symbol | string | number;\n"],"names":["SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","_b","call","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","mounted","l","size","t","has","write","listener","createStore","initialValues","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","MODE","Set","value","atomState","v","r","y","d","Object","freeze","console","warn","set","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","get","delete","cancelAllSuspensePromiseInCache","versionSet","add","forEach","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","flushPending","is","Array","from","keys","every","a","setAtomReadError","error","e","setAtomSuspensePromise","_objectSpread","setAtomPromiseOrValue","promiseOrValue","readAtomState","catch","setAtomInvalidated","force","_","aState","init","Error","read","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mountAtom","canUnmountAtom","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","pending","clear","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createScopeContainer","unstable_createStore","store","SECRET_INTERNAL_store","s","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","unstable_enableVersionedWrite","useState","setVersion","useEffect","scopeContainer","scopeContainerRef","current","w","useRef","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","createElement","keyCount","key","config","toString","useAtomValue","ScopeContext","useContext","versionFromProvider","getAtomValue","version2","useReducer","prev","nextValue","initialVersion","initialValue","valueFromReducer","atomFromReducer","rerenderIfChanged","versionFromProvider2","unsubscribe","useDebugValue","useSetAtom","versionedWrite","useCallback","useAtom","RESET","atomWithReset","anAtom","hydratedMap","useHydrateAtoms","SECRET_INTERNAL_getScopeContext","hydratedSet","getHydratedSet","tuplesToRestore","tuple","push","length","WeakSet","setPath","target","paths","next","i","path","isNaN","Form","props","atomProps","FormAtom","form","useFormAtom","render","InputField","fieldAtom","useFieldAtom","useFieldAtomInitialValue","state","actions","component","Field","fieldAtomState","useFieldAtomState","fieldAtomStateActions","useFieldAtomActions","count","formAtom","fields","fieldsAtom","valuesAtom","walkFields","field","validateFields","event","dirty","ptr","_validateCount","touched","maybePromise","_validateCallback","isPromise","validateStatus","errors","nextField","validate","promises","all","validateResultAtom","status","fieldStatus","validateAtom","errorsAtom","submitCountAtom","submitStatusCountAtom","submitResultAtom","submitAtom","onSubmit","resolveSubmit","submission","dirtyAtom","touchedFieldsAtom","touchedFields","resetAtom","reset","submit","submitStatus","submitCount","fieldAtoms","handleSubmit","useTransition","startTransition","preventDefault","React","useMemo","useFormAtomState","useFormAtomActions","updateFields","useFormAtomErrors","useFormAtomValues","useFormAtomStatus","useFormAtomSubmit","nameAtom","name","valueAtom","touchedAtom","validateCountAtom","resolveErrors","maybeValidatePromise","refAtom","ref","setValue","setTouched","setErrors","focus","useFieldAtomProps","onBlur","onChange","useFieldAtomValue","useFieldAtomErrors","undefined","isAtom","maybeAtom","visitor","isArray","subField","pop"],"mappings":"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"}