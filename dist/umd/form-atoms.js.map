{"version":3,"file":"form-atoms.js","sources":["../../node_modules/jotai/esm/index.js","../../node_modules/jotai/esm/utils.js","../../src/utils.ts","../../src/index.tsx"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(\n            () => writeGetter(a, options)\n          );\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n","import { atom, SECRET_INTERNAL_getScopeContext, useAtom, useSetAtom } from 'jotai';\nexport { useAtomValue, useSetAtom as useUpdateAtom } from 'jotai';\nimport { useContext, useCallback, useMemo } from 'react';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(initialValue, (get, set, update) => {\n    if (update === RESET) {\n      set(anAtom, initialValue);\n    } else {\n      set(\n        anAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  });\n  return anAtom;\n}\n\nconst WRITE_ATOM = \"w\";\nconst RESTORE_ATOMS = \"h\";\n\nfunction useResetAtom(anAtom, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const store = useContext(ScopeContext).s;\n  const setAtom = useCallback(\n    () => store[WRITE_ATOM](anAtom, RESET),\n    [store, anAtom]\n  );\n  return setAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, scope) {\n  const [state, setState] = useAtom(anAtom, scope);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        atoms.delete(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getWeakCacheItem = (cache, deps) => {\n  do {\n    const [dep, ...rest] = deps;\n    const entry = cache.get(dep);\n    if (!entry) {\n      return;\n    }\n    if (!rest.length) {\n      return entry[1];\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst setWeakCacheItem = (cache, deps, item) => {\n  do {\n    const [dep, ...rest] = deps;\n    let entry = cache.get(dep);\n    if (!entry) {\n      entry = [ new WeakMap()];\n      cache.set(dep, entry);\n    }\n    if (!rest.length) {\n      entry[1] = item;\n      return;\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst createMemoizeAtom = () => {\n  const cache = /* @__PURE__ */ new WeakMap();\n  const memoizeAtom = (createAtom, deps) => {\n    const cachedAtom = getWeakCacheItem(cache, deps);\n    if (cachedAtom) {\n      return cachedAtom;\n    }\n    const createdAtom = createAtom();\n    setWeakCacheItem(cache, deps, createdAtom);\n    return createdAtom;\n  };\n  return memoizeAtom;\n};\n\nconst memoizeAtom$4 = createMemoizeAtom();\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memoizeAtom$4(() => {\n    const refAtom = atom(() => ({}));\n    const derivedAtom = atom((get) => {\n      const slice = selector(get(anAtom));\n      const ref = get(refAtom);\n      if (\"prev\" in ref && equalityFn(ref.prev, slice)) {\n        return ref.prev;\n      }\n      ref.prev = slice;\n      return slice;\n    });\n    return derivedAtom;\n  }, [anAtom, selector, equalityFn]);\n}\n\nfunction useAtomCallback(callback, scope) {\n  const anAtom = useMemo(\n    () => atom(\n      null,\n      (get, set, [arg, resolve, reject]) => {\n        try {\n          resolve(callback(get, set, arg));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    ),\n    [callback]\n  );\n  const invoke = useSetAtom(anAtom, scope);\n  return useCallback(\n    (arg) => {\n      let isSync = true;\n      let settled = {};\n      const promise = new Promise((resolve, reject) => {\n        invoke([\n          arg,\n          (v) => {\n            if (isSync) {\n              settled = { v };\n            } else {\n              resolve(v);\n            }\n          },\n          (e) => {\n            if (isSync) {\n              settled = { e };\n            } else {\n              reject(e);\n            }\n          }\n        ]);\n      });\n      isSync = false;\n      if (\"e\" in settled) {\n        throw settled.e;\n      }\n      if (\"v\" in settled) {\n        return settled.v;\n      }\n      return promise;\n    },\n    [invoke]\n  );\n}\n\nconst memoizeAtom$3 = createMemoizeAtom();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memoizeAtom$3(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, [anAtom]);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get) => deepFreeze(origRead(get));\n    return anAtom;\n  };\n}\n\nconst memoizeAtom$2 = createMemoizeAtom();\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memoizeAtom$2(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read2 = (get) => {\n            const ref = get(refAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write2 = (get, set, update) => {\n            const ref = get(refAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            set(arrAtom, [\n              ...arr2.slice(0, index2),\n              nextItem,\n              ...arr2.slice(index2 + 1)\n            ]);\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read2, write2) : atom(read2);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const refAtom = atom(() => ({}));\n      const read = (get) => {\n        const ref = get(refAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, ref.prev);\n        ref.prev = arr;\n        return mapping.atomList;\n      };\n      const write = (get, set, action) => {\n        if (\"read\" in action) {\n          console.warn(\"atomToRemove is deprecated. use action with type\");\n          action = { type: \"remove\", atom: action };\n        }\n        switch (action.type) {\n          case \"remove\": {\n            const index = get(splittedAtom).indexOf(action.atom);\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                ...arr.slice(index + 1)\n              ]);\n            }\n            break;\n          }\n          case \"insert\": {\n            const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                action.value,\n                ...arr.slice(index)\n              ]);\n            }\n            break;\n          }\n          case \"move\": {\n            const index1 = get(splittedAtom).indexOf(action.atom);\n            const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index1 >= 0 && index2 >= 0) {\n              const arr = get(arrAtom);\n              if (index1 < index2) {\n                set(arrAtom, [\n                  ...arr.slice(0, index1),\n                  ...arr.slice(index1 + 1, index2),\n                  arr[index1],\n                  ...arr.slice(index2)\n                ]);\n              } else {\n                set(arrAtom, [\n                  ...arr.slice(0, index2),\n                  arr[index1],\n                  ...arr.slice(index2, index1),\n                  ...arr.slice(index1 + 1)\n                ]);\n              }\n            }\n            break;\n          }\n        }\n      };\n      const splittedAtom = isWritable(arrAtom) ? atom(read, write) : atom(read);\n      return splittedAtom;\n    },\n    keyExtractor ? [arrAtom, keyExtractor] : [arrAtom]\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  const anAtom = atom(\n    (get) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        return set(overwrittenAtom, EMPTY);\n      }\n      return set(\n        overwrittenAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  );\n  return anAtom;\n}\n\nconst memoizeAtom$1 = createMemoizeAtom();\nconst emptyArrayAtom = atom(() => []);\nfunction waitForAll(atoms) {\n  const createAtom = () => {\n    const unwrappedAtoms = unwrapAtoms(atoms);\n    const derivedAtom = atom((get) => {\n      const promises = [];\n      const values = unwrappedAtoms.map((anAtom, index) => {\n        try {\n          return get(anAtom);\n        } catch (e) {\n          if (e instanceof Promise) {\n            promises[index] = e;\n          } else {\n            throw e;\n          }\n        }\n      });\n      if (promises.length) {\n        throw Promise.all(promises);\n      }\n      return wrapResults(atoms, values);\n    });\n    return derivedAtom;\n  };\n  if (Array.isArray(atoms)) {\n    if (atoms.length) {\n      return memoizeAtom$1(createAtom, atoms);\n    }\n    return emptyArrayAtom;\n  }\n  return createAtom();\n}\nconst unwrapAtoms = (atoms) => Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map((key) => atoms[key]);\nconst wrapResults = (atoms, results) => Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce(\n  (out, key, idx) => ({ ...out, [key]: results[idx] }),\n  {}\n);\n\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  return {\n    getItem: (key) => {\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          lastValue = JSON.parse(str2);\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = getStringStorage().getItem(key);\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => getStringStorage().setItem(key, JSON.stringify(newValue)),\n    removeItem: (key) => getStringStorage().removeItem(key)\n  };\n}\nconst defaultStorage = createJSONStorage(() => localStorage);\ndefaultStorage.subscribe = (key, callback) => {\n  const storageEventCallback = (e) => {\n    if (e.key === key && e.newValue) {\n      callback(JSON.parse(e.newValue));\n    }\n  };\n  window.addEventListener(\"storage\", storageEventCallback);\n  return () => {\n    window.removeEventListener(\"storage\", storageEventCallback);\n  };\n};\nfunction atomWithStorage(key, initialValue, storage = defaultStorage) {\n  const getInitialValue = () => {\n    try {\n      const value = storage.getItem(key);\n      if (value instanceof Promise) {\n        return value.catch(() => initialValue);\n      }\n      return value;\n    } catch {\n      return initialValue;\n    }\n  };\n  const baseAtom = atom(storage.delayInit ? initialValue : getInitialValue());\n  baseAtom.onMount = (setAtom) => {\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom);\n      setAtom(getInitialValue());\n    }\n    if (storage.delayInit) {\n      const value = getInitialValue();\n      if (value instanceof Promise) {\n        value.then(setAtom);\n      } else {\n        setAtom(value);\n      }\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      if (update === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      const newValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      set(baseAtom, newValue);\n      return storage.setItem(key, newValue);\n    }\n  );\n  return anAtom;\n}\nfunction atomWithHash(key, initialValue, options) {\n  const serialize = (options == null ? void 0 : options.serialize) || JSON.stringify;\n  const deserialize = (options == null ? void 0 : options.deserialize) || JSON.parse;\n  const subscribe = (options == null ? void 0 : options.subscribe) || ((callback) => {\n    window.addEventListener(\"hashchange\", callback);\n    return () => {\n      window.removeEventListener(\"hashchange\", callback);\n    };\n  });\n  const hashStorage = {\n    getItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      const storedValue = searchParams.get(key2);\n      if (storedValue === null) {\n        throw new Error(\"no value stored\");\n      }\n      return deserialize(storedValue);\n    },\n    setItem: (key2, newValue) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.set(key2, serialize(newValue));\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(null, \"\", \"#\" + searchParams.toString());\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    removeItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.delete(key2);\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(null, \"\", \"#\" + searchParams.toString());\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    ...(options == null ? void 0 : options.delayInit) && { delayInit: true },\n    subscribe: (key2, setValue) => {\n      const callback = () => {\n        const searchParams = new URLSearchParams(location.hash.slice(1));\n        const str = searchParams.get(key2);\n        if (str !== null) {\n          setValue(deserialize(str));\n        } else {\n          setValue(initialValue);\n        }\n      };\n      return subscribe(callback);\n    }\n  };\n  return atomWithStorage(key, initialValue, hashStorage);\n}\n\nfunction atomWithObservable(createObservable, options) {\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = createObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    const EMPTY = Symbol();\n    let resolveEmittedInitialValue = null;\n    let initialEmittedValue = (options == null ? void 0 : options.initialValue) === void 0 ? new Promise((resolve) => {\n      resolveEmittedInitialValue = resolve;\n    }) : void 0;\n    let initialValueWasEmitted = false;\n    let emittedValueBeforeMount = EMPTY;\n    let isSync = true;\n    let setData = (data) => {\n      if ((options == null ? void 0 : options.initialValue) === void 0 && !initialValueWasEmitted) {\n        if (isSync) {\n          initialEmittedValue = data;\n        }\n        resolveEmittedInitialValue == null ? void 0 : resolveEmittedInitialValue(data);\n        initialValueWasEmitted = true;\n        resolveEmittedInitialValue = null;\n      } else {\n        emittedValueBeforeMount = data;\n      }\n    };\n    const dataListener = (data) => {\n      setData(data);\n    };\n    const errorListener = (error) => {\n      setData(Promise.reject(error));\n    };\n    let subscription = null;\n    let initialValue;\n    if ((options == null ? void 0 : options.initialValue) !== void 0) {\n      initialValue = getInitialValue(options);\n    } else {\n      subscription = observable.subscribe(dataListener, errorListener);\n      initialValue = initialEmittedValue;\n    }\n    isSync = false;\n    const dataAtom = atom(initialValue);\n    dataAtom.onMount = (update) => {\n      setData = update;\n      if (emittedValueBeforeMount !== EMPTY) {\n        update(emittedValueBeforeMount);\n      }\n      if (!subscription) {\n        subscription = observable.subscribe(dataListener, errorListener);\n      }\n      return () => {\n        subscription == null ? void 0 : subscription.unsubscribe();\n        subscription = null;\n      };\n    };\n    return { dataAtom, observable };\n  });\n  const observableAtom = atom(\n    (get) => {\n      const { dataAtom } = get(observableResultAtom);\n      return get(dataAtom);\n    },\n    (get, set, data) => {\n      const { dataAtom, observable } = get(observableResultAtom);\n      if (\"next\" in observable) {\n        let subscription = null;\n        const callback = (data2) => {\n          set(dataAtom, data2);\n          subscription == null ? void 0 : subscription.unsubscribe();\n        };\n        subscription = observable.subscribe(callback);\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\nfunction getInitialValue(options) {\n  const initialValue = options.initialValue;\n  return initialValue instanceof Function ? initialValue() : initialValue;\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const store = scopeContainer.s;\n  const hydratedSet = getHydratedSet(scopeContainer);\n  const tuplesToRestore = [];\n  for (const tuple of values) {\n    const atom = tuple[0];\n    if (!hydratedSet.has(atom)) {\n      hydratedSet.add(atom);\n      tuplesToRestore.push(tuple);\n    }\n  }\n  if (tuplesToRestore.length) {\n    store[RESTORE_ATOMS](tuplesToRestore);\n  }\n}\nfunction getHydratedSet(scopeContainer) {\n  let hydratedSet = hydratedMap.get(scopeContainer);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(scopeContainer, hydratedSet);\n  }\n  return hydratedSet;\n}\n\nconst memoizeAtom = createMemoizeAtom();\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memoizeAtom(() => {\n    const loadableAtomCache = /* @__PURE__ */ new WeakMap();\n    const catchAtom = atom((get) => {\n      let promise;\n      try {\n        const data = get(anAtom);\n        const loadableAtom2 = atom({ state: \"hasData\", data });\n        return loadableAtom2;\n      } catch (error) {\n        if (error instanceof Promise) {\n          promise = error;\n        } else {\n          const loadableAtom2 = atom({\n            state: \"hasError\",\n            error\n          });\n          return loadableAtom2;\n        }\n      }\n      const cached = loadableAtomCache.get(promise);\n      if (cached) {\n        return cached;\n      }\n      const loadableAtom = atom(\n        LOADING,\n        async (get2, set) => {\n          try {\n            const data = await get2(anAtom, { unstable_promise: true });\n            set(loadableAtom, { state: \"hasData\", data });\n          } catch (error) {\n            set(loadableAtom, { state: \"hasError\", error });\n          }\n        }\n      );\n      loadableAtom.onMount = (init) => {\n        init();\n      };\n      loadableAtomCache.set(promise, loadableAtom);\n      return loadableAtom;\n    });\n    const derivedAtom = atom((get) => {\n      const loadableAtom = get(catchAtom);\n      return get(loadableAtom);\n    });\n    return derivedAtom;\n  }, [anAtom]);\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithHash, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom, waitForAll };\n","export function setPath(target: any, paths: string[], value: unknown) {\n  if (paths.length === 1) {\n    target[paths[0]] = value;\n    return target;\n  }\n\n  let next = target;\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (i === paths.length - 1) {\n      next[path] = value;\n    } else {\n      const current = next[path];\n      next = next[path] = current ?? (isNaN(paths[i + 1] as any) ? {} : []);\n    }\n  }\n}\n","import type {\n  Atom,\n  ExtractAtomUpdate,\n  ExtractAtomValue,\n  Getter,\n  Setter,\n  WritableAtom,\n} from \"jotai\";\nimport { atom, Provider, useAtom, useAtomValue, useSetAtom } from \"jotai\";\nimport { atomWithReset, RESET, useHydrateAtoms } from \"jotai/utils\";\nimport * as React from \"react\";\nimport { setPath } from \"./utils\";\n\n//\n// Components\n//\n\n/**\n * A React component that renders form atoms and their fields in an isolated\n * scope using a Jotai Provider.\n *\n * @param {FormProps<Fields>} props - Component props\n */\nexport function Form<Fields extends FormAtomFields>(props: FormProps<Fields>) {\n  const { scope, ...atomProps } = props;\n  return (\n    <Provider scope={scope}>\n      <FormAtom {...atomProps} />\n    </Provider>\n  );\n}\n\nfunction FormAtom<Fields extends FormAtomFields>(\n  props:\n    | {\n        atom: FormAtom<Fields>;\n        render(props: UseFormAtom<Fields>): JSX.Element;\n      }\n    | {\n        atom: FormAtom<Fields>;\n        component: React.ComponentType<UseFormAtom<Fields>>;\n      }\n) {\n  const form = useFormAtom(props.atom);\n\n  if (\"render\" in props) {\n    return props.render(form);\n  }\n\n  return <props.component {...form} />;\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that are rendered as native HTML elements because\n * the props can unpack directly into the underlying component.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function InputField<Value extends string | number | string[]>(\n  props: InputFieldProps<Value>\n) {\n  const fieldAtom = useFieldAtom(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtom.props, fieldAtom.state, fieldAtom.actions);\n  }\n\n  return React.createElement(props.component, fieldAtom.props);\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that aren't rendered as native HTML elements.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function Field<Value>(props: FieldProps<Value>) {\n  const fieldAtomState = useFieldAtomState(props.atom, props.scope);\n  const fieldAtomStateActions = useFieldAtomActions(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtomState, fieldAtomStateActions);\n  }\n\n  return (\n    <props.component state={fieldAtomState} actions={fieldAtomStateActions} />\n  );\n}\n\n//\n// Forms\n//\n\n/**\n * An atom that derives its state fields atoms and allows you to submit,\n * validate, and reset your form.\n *\n * @param {FormAtomFields} fields - An object containing field atoms to\n *   be included in the form. Field atoms can be deeply nested in\n *   objects and arrays.\n * @returns The `formAtom` function returns a Jotai `Atom`\n *   comprised of other atoms for managing the state of the form.\n */\nexport function formAtom<Fields extends FormAtomFields>(\n  fields: Fields\n): FormAtom<Fields> {\n  const fieldsAtom = atomWithReset(fields);\n  const valuesAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const values = {} as FormAtomValues<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(values, path, get(fieldAtom.value));\n    });\n\n    return values;\n  });\n\n  async function validateFields(\n    get: Getter,\n    set: Setter,\n    event: FieldAtomValidateOn\n  ) {\n    const fields = get(fieldsAtom);\n    const promises: Promise<boolean>[] = [];\n\n    walkFields(fields, (nextField) => {\n      async function validate(field: typeof nextField) {\n        const fieldAtom = get(field);\n        const value = get(fieldAtom.value);\n        const dirty = get(fieldAtom.dirty);\n        // This pointer prevents a stale validation result from being\n        // set after the most recent validation has been performed.\n        const ptr = get(fieldAtom._validateCount) + 1;\n        set(fieldAtom._validateCount, ptr);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(fieldAtom.touched, true);\n        }\n\n        const maybePromise = fieldAtom._validateCallback?.({\n          get,\n          value,\n          dirty,\n          touched: get(fieldAtom.touched),\n          event,\n        });\n\n        let errors: string[];\n\n        if (isPromise(maybePromise)) {\n          set(fieldAtom.validateStatus, \"validating\");\n          errors = (await maybePromise) ?? get(fieldAtom.errors);\n        } else {\n          errors = maybePromise ?? get(fieldAtom.errors);\n        }\n\n        if (ptr === get(fieldAtom._validateCount)) {\n          set(fieldAtom.errors, errors);\n          set(\n            fieldAtom.validateStatus,\n            errors.length > 0 ? \"invalid\" : \"valid\"\n          );\n        }\n\n        if (errors && errors.length) {\n          return false;\n        }\n\n        return true;\n      }\n\n      promises.push(validate(nextField));\n    });\n\n    await Promise.all(promises);\n  }\n\n  const validateResultAtom = atom<FormAtomValidateStatus>((get) => {\n    const fields = get(fieldsAtom);\n    let status: FormAtomValidateStatus = \"valid\";\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      const fieldStatus = get(fieldAtom.validateStatus);\n\n      if (fieldStatus === \"validating\") {\n        status = \"validating\";\n        return false;\n      } else if (fieldStatus === \"invalid\") {\n        status = \"invalid\";\n        return false;\n      }\n    });\n\n    return status;\n  });\n\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      event && validateFields(get, set, event);\n    }\n  );\n\n  const errorsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const errors = {} as FormAtomErrors<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(errors, path, get(fieldAtom.errors));\n    });\n\n    return errors;\n  });\n\n  const submitCountAtom = atom(0);\n  const submitStatusCountAtom = atom(0);\n  const submitResultAtom = atom<FormAtomSubmitStatus>(\"idle\");\n  const submitAtom = atom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >(null, (get, set, onSubmit) => {\n    async function resolveSubmit() {\n      // This pointer prevents a stale validation result from being\n      // set after the most recent validation has been performed.\n      const ptr = get(submitStatusCountAtom) + 1;\n      set(submitStatusCountAtom, ptr);\n      set(submitCountAtom, (count) => ++count);\n      await validateFields(get, set, \"submit\");\n      const validateStatus = get(validateResultAtom);\n\n      if (validateStatus === \"invalid\") {\n        return (\n          ptr === get(submitStatusCountAtom) && set(submitResultAtom, \"idle\")\n        );\n      }\n\n      const submission = onSubmit(get(valuesAtom));\n\n      try {\n        if (isPromise(submission)) {\n          ptr === get(submitStatusCountAtom) &&\n            set(submitResultAtom, \"submitting\");\n          await submission;\n        }\n        // eslint-disable-next-line no-empty\n      } catch (err) {\n      } finally {\n        if (ptr === get(submitStatusCountAtom)) {\n          set(submitResultAtom, \"submitted\");\n        }\n      }\n    }\n\n    resolveSubmit();\n  });\n\n  const dirtyAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    let dirty = false;\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      dirty = get(fieldAtom.dirty);\n      if (dirty) return false;\n    });\n\n    return dirty;\n  });\n\n  const touchedFieldsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const touchedFields = {} as FormAtomTouchedFields<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(touchedFields, path, get(fieldAtom.touched));\n    });\n\n    return touchedFields;\n  });\n\n  const resetAtom = atom(null, (get, set) => {\n    const fields = get(fieldsAtom);\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      set(fieldAtom.reset);\n    });\n\n    set(submitStatusCountAtom, (current) => ++current);\n    set(submitResultAtom, \"idle\");\n  });\n\n  return atom({\n    fields: fieldsAtom,\n    values: valuesAtom,\n    errors: errorsAtom,\n    dirty: dirtyAtom,\n    touchedFields: touchedFieldsAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    submit: submitAtom,\n    submitStatus: submitResultAtom,\n    submitCount: submitCountAtom,\n    reset: resetAtom,\n  });\n}\n\n/**\n * A hook that returns an object that contains the `fieldAtoms` and actions to\n * validate, submit, and reset the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of functions that can be used to interact\n *   with the form.\n */\nexport function useFormAtom<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): UseFormAtom<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      reset,\n      submit(onSubmit) {\n        return (e) => {\n          e?.preventDefault();\n          startTransition(() => {\n            handleSubmit(onSubmit);\n          });\n        };\n      },\n    }),\n    [fieldAtoms, validate, reset, handleSubmit]\n  );\n}\n\n/**\n * A hook that returns the primary state of the form atom including values, errors,\n * submit and validation status, as well as the `fieldAtoms`. Note that this\n * hook will cuase its parent component to re-render any time those states\n * change, so it can be useful to use more targeted state hooks like\n * `useFormAtomStatus`.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomState<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomState<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const submitCount = useAtomValue(form.submitCount, scope);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n  const values = useAtomValue(form.values, scope);\n  const errors = useAtomValue(form.errors, scope);\n  const dirty = useAtomValue(form.dirty, scope);\n  const touchedFields = useAtomValue(form.touchedFields, scope);\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      values: values as any,\n      errors: errors as any,\n      dirty,\n      touchedFields: touchedFields as any,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    }),\n    [\n      fieldAtoms,\n      values,\n      errors,\n      dirty,\n      touchedFields,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    ]\n  );\n}\n\n/**\n * A hook that returns a set of actions that can be used to update the state\n * of the form atom. This includes updating fields, submitting, resetting,\n * and validating the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomActions<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomActions<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const updateFields = useSetAtom(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const submit = React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        handleSubmit(values);\n      },\n    [handleSubmit]\n  );\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      updateFields,\n      reset,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      submit,\n    }),\n    [updateFields, reset, validate, submit]\n  );\n}\n\n/**\n * A hook that returns the errors of the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form data.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the form.\n */\nexport function useFormAtomErrors<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.errors, scope);\n}\n\n/**\n * A hook that returns the values of the form atom\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The values of the form.\n */\nexport function useFormAtomValues<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.values, scope);\n}\n\n/**\n * A hook that returns the `submitStatus` and `validateStatus` of\n * the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns An object containing the `submitStatus` and\n *   `validateStatus` of the form\n */\nexport function useFormAtomStatus<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomStatus {\n  const form = useAtomValue(formAtom);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n\n  return React.useMemo(\n    () => ({ submitStatus, validateStatus }),\n    [submitStatus, validateStatus]\n  );\n}\n\n/**\n * A hook that returns a callback for handling form submission.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A callback for handling form submission. The callback\n *   takes the form values as an argument and returs an additional callback\n *   that invokes `event.preventDefault()` if it receives an event as its argument.\n */\nexport function useFormAtomSubmit<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const [, startTransition] = useTransition();\n  const form = useAtomValue(formAtom, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  return React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        startTransition(() => {\n          handleSubmit(values);\n        });\n      },\n    [handleSubmit]\n  );\n}\n\n//\n// Fields\n//\n\n/**\n * An atom that represents a field in a form. It manages state for the field,\n * including the name, value, errors, dirty, validation, and touched state.\n *\n * @param {FieldAtomConfig<Value>} config - The initial state and configuration of the field.\n * @returns A FieldAtom.\n */\nexport function fieldAtom<Value>(\n  config: FieldAtomConfig<Value>\n): FieldAtom<Value> {\n  const nameAtom = atomWithReset(config.name);\n  const valueAtom = atomWithReset<Value>(config.value);\n  const touchedAtom = atomWithReset(config.touched ?? false);\n  const dirtyAtom = atom((get) => {\n    return get(valueAtom) !== config.value;\n  });\n  const errorsAtom = atom<string[]>([]);\n\n  const validateCountAtom = atom(0);\n  const validateResultAtom = atom<FormAtomValidateStatus>(\"valid\");\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      async function resolveErrors() {\n        if (!event) return;\n        // This pointer prevents a stale validation result from being\n        // set to state after the most recent invocation of validate.\n        const ptr = get(validateCountAtom) + 1;\n        set(validateCountAtom, ptr);\n        const dirty = get(dirtyAtom);\n        const value = get(valueAtom);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(touchedAtom, true);\n        }\n\n        let errors: string[] = [];\n\n        const maybeValidatePromise = config.validate?.({\n          get,\n          dirty,\n          touched: get(touchedAtom),\n          value,\n          event: event,\n        });\n\n        if (isPromise(maybeValidatePromise)) {\n          ptr === get(validateCountAtom) &&\n            set(validateResultAtom, \"validating\");\n          errors = (await maybeValidatePromise) ?? get(errorsAtom);\n        } else {\n          errors = maybeValidatePromise ?? get(errorsAtom);\n        }\n\n        if (ptr === get(validateCountAtom)) {\n          set(errorsAtom, errors);\n          set(validateResultAtom, errors.length > 0 ? \"invalid\" : \"valid\");\n        }\n      }\n\n      resolveErrors();\n    }\n  );\n\n  const refAtom = atom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n  >(null);\n\n  const resetAtom = atom<null, void>(null, (get, set) => {\n    set(errorsAtom, []);\n    set(touchedAtom, RESET);\n    set(valueAtom, RESET);\n    // Need to set a new pointer to prevent stale validation results\n    // from being set to state after this invocation.\n    set(validateCountAtom, (count) => ++count);\n    set(validateResultAtom, \"valid\");\n  });\n\n  return atom({\n    name: nameAtom,\n    value: valueAtom,\n    touched: touchedAtom,\n    dirty: dirtyAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    errors: errorsAtom,\n    reset: resetAtom,\n    ref: refAtom,\n    _validateCallback: config.validate,\n    _validateCount: validateCountAtom,\n  });\n}\n\n/**\n * A hook that returns a set of actions that can be used to interact with the\n * field atom state.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of actions that can be used to interact with the field atom.\n */\nexport function useFieldAtomActions<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomActions<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const setValue = useSetAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const setErrors = useSetAtom(field.errors, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const reset = useSetAtom(field.reset, scope);\n  const ref = useAtomValue(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      setValue(value) {\n        setValue(value);\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n      setTouched(touched) {\n        setTouched(touched);\n\n        if (touched) {\n          startTransition(() => {\n            validate(\"touch\");\n          });\n        }\n      },\n      setErrors,\n      focus() {\n        ref?.focus();\n      },\n      reset,\n    }),\n    [setErrors, reset, validate, setValue, setTouched, ref]\n  );\n}\n\n/**\n * A hook that returns a set of props that can be destructured\n * directly into an `<input>`, `<select>`, or `<textarea>` element.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of props that can be destructured directly into an `<input>`,\n *   `<select>`, or `<textarea>` element.\n */\nexport function useFieldAtomProps<\n  Value\n>(fieldAtom: FieldAtom<Value>, scope?: Scope): FieldAtomProps<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const name = useAtomValue(field.name, scope);\n  const [value, setValue] = useAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const ref = useSetAtom(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      name,\n      value: value as Value,\n      \"aria-invalid\": validateStatus === \"invalid\",\n      ref,\n      onBlur() {\n        setTouched(true);\n        startTransition(() => {\n          validate(\"blur\");\n        });\n      },\n      onChange(event) {\n        // @ts-expect-error\n        setValue(event.target.value);\n\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n    }),\n    [name, value, validateStatus, ref, setTouched, validate, setValue]\n  );\n}\n\n/**\n * A hook that returns the state of a field atom. This includes the field's\n * value, whether it has been touched, whether it is dirty, the validation status,\n * and any errors.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The state of the field atom.\n */\nexport function useFieldAtomState<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomState<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const value = useAtomValue(field.value, scope);\n  const touched = useAtomValue(field.touched, scope);\n  const dirty = useAtomValue(field.dirty, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const errors = useAtomValue(field.errors, scope);\n\n  return React.useMemo(\n    () => ({\n      value: value as unknown as Value,\n      touched,\n      dirty,\n      validateStatus,\n      errors,\n    }),\n    [value, touched, dirty, validateStatus, errors]\n  );\n}\n\n/**\n * A hook that returns the value of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The value of the field atom.\n */\nexport function useFieldAtomValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.value, scope);\n}\n\n/**\n * A hook that returns the errors of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtomErrors<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.errors, scope);\n}\n\n/**\n * Sets the initial value of a field atom. Initial values can only be set once\n * per scope. Therefore, if the initial value used is changed during rerenders,\n * it won't update the atom value.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that you want to use to store the value.\n * @param {Value} initialValue - The initial value of the field.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFieldAtomInitialValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  initialValue?: Value,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  useHydrateAtoms(\n    initialValue === undefined ? [] : [[field.value, initialValue] as const],\n    scope\n  );\n}\n\n/**\n * A hook that returns `props`, `state`, and `actions` of a field atom from\n * `useFieldAtomProps`, `useFieldAtomState`, and `useFieldAtomActions`.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtom<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): UseFieldAtom<Value> {\n  const props = useFieldAtomProps<Value>(fieldAtom, scope);\n  const actions = useFieldAtomActions<Value>(fieldAtom, scope);\n  const state = useFieldAtomState<Value>(fieldAtom, scope);\n  return React.useMemo<UseFieldAtom<Value>>(\n    () => ({ props, actions, state }),\n    [props, actions, state]\n  );\n}\n\nconst useTransition: () => [boolean, typeof React.startTransition] =\n  typeof React.useTransition === \"function\"\n    ? React.useTransition\n    : () => [false, (fn) => fn()];\n\nfunction isPromise(value: any): value is Promise<any> {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n}\n\nfunction isAtom(maybeAtom: any): maybeAtom is FieldAtom<any> {\n  return (\n    maybeAtom !== null &&\n    typeof maybeAtom === \"object\" &&\n    (typeof maybeAtom.read === \"function\" ||\n      typeof maybeAtom.write === \"function\")\n  );\n}\n\n/**\n * A function that walks through an object containing nested field atoms\n * and calls a visitor function for each atom it finds.\n *\n * @param {FormAtomFields} fields - An object containing nested field atoms\n * @param visitor - A function that will be called for each field atom. You can\n *  exit early by returning `false` from the function.\n * @param path - The base path of the field atom.\n */\nexport function walkFields<Fields extends FormAtomFields>(\n  fields: Fields,\n  visitor: (field: FieldAtom<any>, path: string[]) => void | false,\n  path: string[] = []\n) {\n  for (const key in fields) {\n    path.push(key);\n    const field = fields[key];\n\n    if (isAtom(field)) {\n      if (visitor(field, path) === false) return;\n    } else if (Array.isArray(field)) {\n      for (const key in field) {\n        path.push(key);\n        const subField = field[key];\n\n        if (isAtom(subField)) {\n          if (visitor(subField, path) === false) return;\n        } else {\n          walkFields(subField, visitor, path);\n        }\n\n        path.pop();\n      }\n    } else if (typeof field === \"object\") {\n      walkFields(field, visitor, path);\n    }\n\n    path.pop();\n  }\n}\n\nexport { Provider } from \"jotai\";\n\nexport type InputFieldProps<Value extends string | number | string[]> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props that can be directly unpacked into a native HTML input element\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        props: FieldAtomProps<Value>,\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component:\n        | \"input\"\n        | \"textarea\"\n        | \"select\"\n        | React.ComponentType<FieldAtomProps<Value>>;\n    };\n\nexport type FieldProps<Value> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component: React.ComponentType<{\n        state: FieldAtomState<Value>;\n        actions: FieldAtomActions<Value>;\n      }>;\n    };\n\nexport type FormProps<Fields extends FormAtomFields> =\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props returned from a `useFormAtom` hook\n       */\n      render(props: UseFormAtom<Fields>): JSX.Element;\n    }\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component.\n       */\n      component: React.ComponentType<UseFormAtom<Fields>>;\n    };\n\n/**\n * A form submission status\n */\nexport type FormAtomSubmitStatus = \"idle\" | \"submitting\" | \"submitted\";\n/**\n * A form and field validation status\n */\nexport type FormAtomValidateStatus = \"validating\" | \"valid\" | \"invalid\";\n/**\n * Event types that a field atom may validate against\n */\nexport type FieldAtomValidateOn =\n  | \"user\"\n  | \"blur\"\n  | \"change\"\n  | \"touch\"\n  | \"submit\";\n\nexport type FieldAtom<Value> = Atom<{\n  /**\n   * An atom containing the field's name\n   */\n  name: WritableAtom<string | undefined, string | undefined | typeof RESET>;\n  /**\n   * An atom containing the field's value\n   */\n  value: WritableAtom<Value, Value | typeof RESET | ((prev: Value) => Value)>;\n  /**\n   * An atom containing the field's touched status\n   */\n  touched: WritableAtom<\n    boolean,\n    boolean | typeof RESET | ((prev: boolean) => boolean)\n  >;\n  /**\n   * An atom containing the field's dirty status\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A write-only atom for validating the field's value\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * An atom containing the field's validation status\n   */\n  validateStatus: WritableAtom<FormAtomValidateStatus, FormAtomValidateStatus>;\n  /**\n   * An atom containing the field's validation errors\n   */\n  errors: WritableAtom<string[], string[] | ((value: string[]) => string[])>;\n  /**\n   * A write-only atom for resetting the field atoms to their\n   * initial states.\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * An atom containing a reference to the `HTMLElement` the field\n   * is bound to.\n   */\n  ref: WritableAtom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null,\n    | HTMLInputElement\n    | HTMLTextAreaElement\n    | HTMLSelectElement\n    | null\n    | ((\n        value: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n      ) => HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null)\n  >;\n  _validateCount: WritableAtom<number, number | ((current: number) => number)>;\n  _validateCallback?: Validate<Value>;\n}>;\n\nexport type FormAtom<Fields extends FormAtomFields> = Atom<{\n  /**\n   * An atom containing an object of nested field atoms\n   */\n  fields: WritableAtom<\n    Fields,\n    Fields | typeof RESET | ((prev: Fields) => Fields),\n    void\n  >;\n  /**\n   * An read-only atom that derives the form's values from\n   * its nested field atoms.\n   */\n  values: Atom<FormAtomValues<Fields>>;\n  /**\n   * An read-only atom that derives the form's errors from\n   * its nested field atoms.\n   */\n  errors: Atom<FormAtomErrors<Fields>>;\n  /**\n   * A read-only atom that returns `true` if any of the fields in\n   * the form are dirty.\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A read-only atom derives the touched state of its nested field atoms.\n   */\n  touchedFields: Atom<FormAtomTouchedFields<Fields>>;\n  /**\n   * A write-only atom that resets the form's nested field atoms\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * A write-only atom that validates the form's nested field atoms\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * A read-only atom that derives the form's validation status\n   */\n  validateStatus: Atom<FormAtomValidateStatus>;\n  /**\n   * A write-only atom for submitting the form\n   */\n  submit: WritableAtom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >;\n  /**\n   * A read-only atom that reads the number of times the form has\n   * been submitted\n   */\n  submitCount: Atom<number>;\n  /**\n   * An atom that contains the form's submission status\n   */\n  submitStatus: WritableAtom<FormAtomSubmitStatus, FormAtomSubmitStatus>;\n}>;\n\n/**\n * An object containing nested field atoms\n */\nexport type FormAtomFields = {\n  [key: string | number]:\n    | FieldAtom<any>\n    | FormAtomFields\n    | FormAtomFields[]\n    | FieldAtom<any>[];\n};\n\n/**\n * An object containing the values of a form's nested field atoms\n */\nexport type FormAtomValues<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<infer Value>\n    ? Value\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\n/**\n * An object containing the errors of a form's nested field atoms\n */\nexport type FormAtomErrors<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? string[]\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomErrors<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomErrors<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport type FormAtomTouchedFields<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? boolean\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport interface UseFormAtom<Fields extends FormAtomFields> {\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface FormAtomStatus {\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomState<Fields extends FormAtomFields> {\n  /**\n   * An object containing the form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  values: FormAtomValues<Fields>;\n  /**\n   * An object containing the errors of a form's nested field atoms\n   */\n  errors: FormAtomErrors<Fields>;\n  /**\n   * `true` if any of the fields in the form are dirty.\n   */\n  dirty: boolean;\n  /**\n   * An object containing the touched state of the form's nested field atoms.\n   */\n  touchedFields: FormAtomTouchedFields<Fields>;\n  /**\n   * The number of times a form has been submitted\n   */\n  submitCount: number;\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomActions<Fields extends FormAtomFields> {\n  /**\n   * A function for adding/removing fields from the form.\n   *\n   * @param fields - An object containing the form's nested field atoms or\n   *   a callback that receives the current fields and returns the next\n   *   fields.\n   */\n  updateFields(\n    fields: ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"fields\"]>\n  ): void;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface UseFieldAtom<Value> {\n  /**\n   * `<input>`, `<select>`, or `<textarea>` props for the field\n   */\n  props: FieldAtomProps<Value>;\n  /**\n   * Actions for managing the state of the field\n   */\n  actions: FieldAtomActions<Value>;\n  /**\n   * The current state of the field\n   */\n  state: FieldAtomState<Value>;\n}\n\nexport interface FieldAtomProps<Value> {\n  /**\n   * The name of the field if there is one\n   */\n  name: string | undefined;\n  /**\n   * The value of the field\n   */\n  value: Value;\n  /**\n   * A WAI-ARIA property that tells a screen reader whether the\n   * field is invalid\n   */\n  \"aria-invalid\": boolean;\n  /**\n   * A React callback ref that is used to bind the field atom to\n   * an `<input>`, `<select>`, or `<textarea>` element so that it\n   * can be read and focused.\n   */\n  ref: React.RefCallback<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n  >;\n  onBlur(event: React.FormEvent<HTMLInputElement>): void;\n  onBlur(event: React.FormEvent<HTMLTextAreaElement>): void;\n  onBlur(event: React.FormEvent<HTMLSelectElement>): void;\n  onChange(event: React.ChangeEvent<HTMLInputElement>): void;\n  onChange(event: React.ChangeEvent<HTMLTextAreaElement>): void;\n  onChange(event: React.ChangeEvent<HTMLSelectElement>): void;\n}\n\nexport interface FieldAtomActions<Value> {\n  /**\n   * A function that validates the field's value with a `\"user\"` validation\n   * event.\n   */\n  validate(): void;\n  /**\n   * A function for changing the value of a field. This will trigger a `\"change\"`\n   * validation event.\n   *\n   * @param {Value} value - The new value of the field\n   */\n  setValue(\n    value: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>\n  ): void;\n  /**\n   * A function for changing the touched state of a field. This will trigger a\n   * `\"touch\"` validation event.\n   *\n   * @param {boolean} touched - The new touched state of the field\n   */\n  setTouched(\n    touched: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>\n  ): void;\n  /**\n   * A function for changing the error state of a field\n   *\n   * @param {string[]} errors - The new error state of the field\n   */\n  setErrors(\n    errors: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>\n  ): void;\n  /**\n   * Focuses the field atom's `<input>`, `<select>`, or `<textarea>` element\n   * if there is one bound to it.\n   */\n  focus(): void;\n  /**\n   * Resets the field atom to its initial state.\n   */\n  reset(): void;\n}\n\nexport interface FieldAtomState<Value> {\n  /**\n   * The value of the field\n   */\n  value: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>;\n  /**\n   * The touched state of the field\n   */\n  touched: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>;\n  /**\n   * The dirty state of the field. A field is \"dirty\" if it's value has\n   * been changed.\n   */\n  dirty: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"dirty\"]>;\n  /**\n   * The validation status of the field\n   */\n  validateStatus: ExtractAtomValue<\n    ExtractAtomValue<FieldAtom<Value>>[\"validateStatus\"]\n  >;\n  /**\n   * The error state of the field\n   */\n  errors: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>;\n}\n\nexport interface FieldAtomConfig<Value> {\n  /**\n   * Optionally provide a name for the field that will be added\n   * to any attached `<input>`, `<select>`, or `<textarea>` elements\n   */\n  name?: string;\n  /**\n   * The initial value of the field\n   */\n  value: Value;\n  /**\n   * The initial touched state of the field\n   */\n  touched?: boolean;\n  /**\n   * A function that validates the value of the field any time\n   * one of its atoms changes. It must either return an array of\n   * string error messages or undefined. If it returns undefined,\n   * the validation is \"skipped\" and the current errors in state\n   * are retained.\n   */\n  validate?: (state: {\n    /**\n     * A Jotai getter that can read other atoms\n     */\n    get: Getter;\n    /**\n     * The current value of the field\n     */\n    value: Value;\n    /**\n     * The dirty state of the field\n     */\n    dirty: boolean;\n    /**\n     * The touched state of the field\n     */\n    touched: boolean;\n    /**\n     * The event that caused the validation. Either:\n     *\n     * - `\"change\"` - The value of the field has changed\n     * - `\"touch\"` - The field has been touched\n     * - `\"blur\"` - The field has been blurred\n     * - `\"submit\"` - The form has been submitted\n     * - `\"user\"` - A user/developer has triggered the validation\n     */\n    event: FieldAtomValidateOn;\n  }) => void | string[] | Promise<void | string[]>;\n}\n\n/**\n * A utility type for easily typing validate functions\n */\nexport type Validate<Value> = FieldAtomConfig<Value>[\"validate\"];\n\n/**\n * A utility type for easily typing validate function configurations\n */\nexport type ValidateConfig<Value> = Parameters<\n  Exclude<FieldAtomConfig<Value>[\"validate\"], undefined>\n>[0];\n\n/**\n * A `Provider` or `useAtom` hook accepts an optional prop scope which you\n * can use for scoped Provider. When using atoms with a scope, the provider\n * with the same scope will be used. The recommendation for the scope value\n * is a unique symbol. The primary use case of scope is for library usage.\n */\nexport type Scope = symbol | string | number;\n"],"names":["atom","mounted","l","size","t","has","_isActuallyWritableAt","write","_ref15","listener","_ref17","read","key","keyCount","config","toString","init","get","set","update","useAtomValue","scope","ScopeContext","getScopeContext","scopeContainer","useContext","store","s","versionFromProvider","v","getAtomValue","version2","atomState","y","Error","e","p","_useReducer","useReducer","prev","nextVersion","nextValue","Object","is","initialVersion","_useReducer$","version","valueFromReducer","atomFromReducer","rerenderIfChanged","value","useEffect","versionFromProvider2","unsubscribe","useDebugValue","useSetAtom","versionedWrite","w","useCallback","atomWithReset","initialValue","anAtom","RESET","setPath","target","paths","length","next","i","path","current","isNaN","FormAtom","props","form","useFormAtom","render","__reactCreateElement__","component","_ref2","count","_ref3","formAtom","_ref5","validate","_ref6","startTransition","_submit","onSubmit","_ref7","handleSubmit","preventDefault","fieldAtoms","fields","reset","submit","useTransition","React","useMemo","_ref4","_ref12","useFieldAtomActions","fieldAtom","_ref14","_ref18","setValue","_ref20","_ref21","touched","setTouched","_focus","ref","focus","field","setErrors","errors","_ref13","_ref16","_ref19","useFieldAtomProps","_ref22","_onBlur","_ref23","_onChange","event","name","_useAtom","console","warn","useAtom","validateStatus","onBlur","onChange","useFieldAtomState","dirty","useFieldAtomInitialValue","values","_step5","SECRET_INTERNAL_getScopeContext","hydratedSet","hydratedMap","WeakSet","getHydratedSet","tuplesToRestore","_iterator5","_createForOfIteratorHelperLoose","done","tuple","add","push","useHydrateAtoms","undefined","useFieldAtom","actions","state","_ref24","fn","isPromise","then","isAtom","maybeAtom","walkFields","visitor","Array","isArray","subField","pop","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","cancelSuspensePromise","suspensePromise","_a","_b","c","call","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","hasInitialValue","createStore","initialValues","prevAtomState","getAtomState","d","mountDependencies","mountedMap","forEach","stateListeners","mountedAtoms","committedAtomStateMap","WeakMap","pendingMap","Map","Set","_step","_iterator","_step$value","r","freeze","suspensePromiseCacheMap","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","setAtomState","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","from","keys","every","a","flushPending","setAtomReadError","error","setAtomSuspensePromise","_objectSpread","cache","delete","addSuspensePromiseToCache","setAtomPromiseOrValue","promiseOrValue","readAtomState","catch","force","isSuspensePromiseAlreadyCancelled","_","aState","_ref","errorOrPromise","canUnmountAtom","_canUnmountAtom","invalidateDependents","dependent","setAtomInvalidated","writeAtomState","isSync","promiseOrVoid","writeGetter","options","unstable_promise","info","promiseOrVoid2","versionSet","cancelAllSuspensePromiseInCache","cancelledVersion","writeAtom","writingAtom","isActuallyWritableAtom","mountAtom","initialDependent","aMounted","onMount","onUnmount","u","unmountAtom","pending","clear","readingAtom","_atom","commitVersionedAtomStateMap","callback","addingAtom","addAtom","listeners","deletingAtom","delAtom","h","_step2","_iterator2","_step2$value","n","m","createScopeContainer","unstable_createStore","SECRET_INTERNAL_store","ScopeContextMap","createContext","Provider","children","unstable_enableVersionedWrite","useState","_useState","setVersion","scopeContainerRef","useRef","retrying","parentVersion","ScopeContainerContext","createElement","fieldAtomState","fieldAtomStateActions","atomProps","_excluded","_config$touched","nameAtom","valueAtom","touchedAtom","dirtyAtom","errorsAtom","validateCountAtom","validateResultAtom","validateAtom","_callee8","_config$validate","ptr","maybeValidatePromise","_yield$maybeValidateP","_regeneratorRuntime","wrap","_context4","abrupt","t1","sent","t0","t2","stop","_resolveErrors","_asyncToGenerator","mark","apply","this","arguments","resolveErrors","refAtom","resetAtom","_validateCallback","_validateCount","validateFields","_x","_x2","_x3","_validateFields","_callee6","_callee5","_fieldAtom$_validateC","maybePromise","_yield$maybePromise","_context2","nextField","_validate","promises","_x4","_context3","fieldsAtom","all","valuesAtom","status","fieldStatus","submitCountAtom","submitStatusCountAtom","submitResultAtom","submitAtom","_callee7","submission","_context","finish","_resolveSubmit","resolveSubmit","touchedFieldsAtom","touchedFields","submitStatus","submitCount","_ref9","_ref10","updateFields","_ref8","_ref11"],"mappings":"isRA4VyB,SAACA,EAAAA,EAAMC,GAAP,OAAoBA,EAAQC,EAAEC,QAAUF,EAAQG,EAAED,MAA2B,IAAnBF,EAAQG,EAAED,MAAcF,EAAQG,EAAEC,IAAIL,GAAhG,CAkFQ,SAAAM,EAACN,GAAD,QAAYA,EAAKO,KAAjB,CA0GoB,SAAAC,EAACC,GAAD,OAAcA,GAAd,CAIxB,SAAAC,EAACR,GAAD,OAAOA,GAAP,CAiK7B,SAASF,EAAKW,EAAMJ,GAClB,IAAMK,EAAa,UAAEC,GACfC,EAAS,CACbC,SAAU,WAAA,OAAMH,CAAN,GAYZ,MAVoB,mBAATD,EACTG,EAAOH,KAAOA,GAEdG,EAAOE,KAAOL,EACdG,EAAOH,KAAO,SAACM,GAAD,OAASA,EAAIH,EAAb,EACdA,EAAOP,MAAQ,SAACU,EAAKC,EAAKC,GAAX,OAAsBD,EAAIJ,EAA0B,mBAAXK,EAAwBA,EAAOF,EAAIH,IAAWK,EAAvF,GAEbZ,IACFO,EAAOP,MAAQA,GAEVO,CACR,CAED,SAASM,EAAapB,EAAMqB,GAC1B,IAAMC,EAAeC,GAAgBF,GAC/BG,EAAiBC,EAAWH,GACvBI,EAAkCF,EAArCG,EAAaC,EAAwBJ,EAA3BK,EACZC,EAAe,SAACC,GACpB,IAAMC,EAAYN,EAAK,EAAY1B,EAAM+B,GACzC,IAAmEC,EAAUC,EAC3E,MAAM,IAAIC,MAAM,6BAElB,GAAI,MAAOF,EACT,MAAMA,EAAUG,EAElB,GAAI,MAAOH,EACT,MAAMA,EAAUI,EAElB,GAAI,MAAOJ,EACT,OAAOA,EAAUH,EAEnB,MAAM,IAAIK,MAAM,kBAElBG,EAA0EC,GACxE,SAACC,EAAMC,GACL,IAAMC,EAAYX,EAAaU,GAC/B,OAAIE,OAAOC,GAAGJ,EAAK,GAAIE,IAAcF,EAAK,KAAOvC,EACxCuC,EAEF,CAACC,EAAaC,EAAWzC,EACjC,GACD4B,GACA,SAACgB,GAEC,MAAO,CAACA,EADad,EAAac,GACI5C,EACvC,IAZH6C,EAAAR,EAAA,GAAQS,EAARD,EAAA,GAAiBE,EAAjBF,EAAA,GAAmCG,EAAnCH,EAAA,GAAqDI,EAArDZ,EAAA,GAcIa,EAAQH,EAsBZ,OArBIC,IAAoBhD,IACtBiD,EAAkBH,GAClBI,EAAQpB,EAAagB,IAEvBK,GAAU,WACR,IAAWC,EAAyB5B,EAA5BK,EACJuB,GACF1B,EAAK,EAAc1B,EAAMoD,GAE3B,IAAMC,EAAc3B,EAAK,EACvB1B,EACAiD,EACAG,GAGF,OADAH,EAAkBG,GACXC,CAXA,GAYN,CAAC3B,EAAO1B,EAAMwB,IACjB2B,GAAU,WACRzB,EAAK,EAAc1B,EAAM8C,EAC1B,IACDQ,EAAcJ,GACPA,CACR,CAED,SAASK,EAAWvD,EAAMqB,GACxB,IAAMC,EAAeC,GAAgBF,GACGI,EAAAA,EAAWH,GAAxCI,IAAHC,EAAa6B,IAAHC,EAWlB,OAVgBC,GACd,SAACvC,GACC,KAAoE,UAAWnB,GAC7E,MAAM,IAAIkC,MAAM,qBAElB,IAAM3B,EAAQ,SAACuC,GAAD,OAAapB,EAAK,EAAa1B,EAAMmB,EAAQ2B,IAC3D,OAAOU,EAAiBA,EAAejD,GAASA,GANzB,GAQzB,CAACmB,EAAO8B,EAAgBxD,GAG3B,CClxBD,SAAS2D,EAAcC,GACrB,IAAMC,EAAS7D,EAAK4D,GAAc,SAAC3C,EAAKC,EAAKC,GAEzCD,EAAI2C,EADF1C,IAAW2C,GACDF,EAIQ,mBAAXzC,EAAwBA,EAAOF,EAAI4C,IAAW1C,EAG1D,IACD,OAAO0C,CACR,CClBM,SAASE,EAAQC,EAAaC,EAAiBf,GACpD,GAAqB,IAAjBe,EAAMC,OAER,OADAF,EAAOC,EAAM,IAAMf,EACZc,EAKT,IAFA,IAAIG,EAAOH,EAEFI,EAAI,EAAGA,EAAIH,EAAMC,OAAQE,IAAK,CACrC,IAAMC,EAAOJ,EAAMG,GACnB,GAAIA,IAAMH,EAAMC,OAAS,EACvBC,EAAKE,GAAQnB,MACR,CACL,IAAMoB,EAAUH,EAAKE,GACrBF,EAAOA,EAAKE,GAAQC,QAAAA,EAAYC,MAAMN,EAAMG,EAAI,IAAa,CAA7B,EAAkC,EACnE,CACF,CACF,CCeD,SAASI,EACPC,GAUA,IAAMC,EAAOC,EAAYF,EAAMzE,MAE/B,MAAI,WAAYyE,EACPA,EAAMG,OAAOF,GAGfG,GAACJ,EAAMK,UAAcJ,EAC7B,CAuL0B,SAAAK,EAACC,GAAD,QAAaA,CAAb,CA8DI,SAAAC,EAACX,GAAD,QAAeA,CAAf,+GA8BxB,SAASK,EACdO,EACA7D,GAasB,SAAM8D,IACpBC,EAAS,OACV,CAdc,SAWNC,IACTC,EAAAH,EAGD,CAfgB,SAAAI,EAiBVC,GAGa,SAAMC,IACpBC,EAAaF,EACd,CAJH,OAAO,SAACrD,GACNA,SAAAA,EAAGwD,iBACHL,EAAAG,GAIH,CAvBL,IAAMf,EAAOtD,EAAa8D,EAAU7D,GAC9BuE,EAAaxE,EAAasD,EAAKmB,OAAQxE,GACvCyE,EAAQvC,EAAWmB,EAAKoB,MAAOzE,GAC/B+D,EAAW7B,EAAWmB,EAAKU,SAAU/D,GACrCqE,EAAenC,EAAWmB,EAAKqB,OAAQ1E,GACpCiE,EAAmBU,KAA5B,GAEA,OAAOC,EAAMC,SACX,WAAA,MAAO,CACLN,WAAYA,EACZR,SAFKe,EAAAd,GAOLS,MAAAA,EACAC,OARKR,EADF,GAkBL,CAACK,EAAYR,EAAUU,EAAOJ,GAEjC,+GAuQ0B,SAAAU,EAACpB,GAAD,QAAaA,CAAb,6UA6BpB,SAASqB,EACdC,EACAjF,GAcsB,SAAMkF,IACpBnB,EAAS,OACV,CAfkB,SAYV5E,IACT8E,EAAAiB,EAGD,CAGiB,SAAM7F,IACpB0E,EAAS,SACV,CArBkB,SAAAoB,EAiBZtD,GACPuD,EAASvD,GACToC,EAAA5E,EAGD,CAKmB,SAAMgG,IACpBtB,EAAS,QACV,CA7BgB,SAAAuB,EAuBVC,GACTC,EAAWD,GAEPA,GACFtB,EAAAoB,EAIH,CA/BoB,SAiCbI,IACNC,SAAAA,EAAKC,OACN,CAlCL,IAAMC,EAAQ7F,EAAakF,EAAWjF,GAChCoF,EAAWlD,EAAW0D,EAAM/D,MAAO7B,GACnCwF,EAAatD,EAAW0D,EAAML,QAASvF,GACvC6F,EAAY3D,EAAW0D,EAAME,OAAQ9F,GACrC+D,EAAW7B,EAAW0D,EAAM7B,SAAU/D,GACtCyE,EAAQvC,EAAW0D,EAAMnB,MAAOzE,GAChC0F,EAAM3F,EAAa6F,EAAMF,IAAK1F,GAC3BiE,EAAmBU,KAA5B,GAEA,OAAOC,EAAMC,SACX,WAAA,MAAO,CACLd,SADKgC,EAAA5G,GAMLiG,SANKY,EAAAb,GAYLK,WAZKS,EAAAX,GAqBLO,UAAAA,EACAF,MAtBKF,EAyBLhB,MAAAA,EAzBF,GA2BA,CAACoB,EAAWpB,EAAOV,EAAUqB,EAAUI,EAAYE,GAEtD,CAaM,SAASQ,EAEdjB,EAA6BjF,GAkBP,SAAMmG,IACpBpC,EAAS,OACV,CApB4D,SAgBtDqC,IACPZ,EAAW,GACXvB,EAAAkC,EAGD,CAKiB,SAAME,IACpBtC,EAAS,SACV,CA5B4D,SAAAuC,EAsBtDC,GAEPnB,EAASmB,EAAM5D,OAAOd,OAEtBoC,EAAAoC,EAGD,CA5BL,IAAMT,EAAQ7F,EAAakF,EAAWjF,GAChCwG,EAAOzG,EAAa6F,EAAMY,KAAMxG,GACtCyG,EHqFF,SAAiB9H,EAAMqB,GAOrB,MANI,UAAWrB,IACb+H,QAAQC,KACN,qEAEF3G,EAAQrB,EAAKqB,OAER,CACLD,EAAapB,EAAMqB,GACnBkC,EAAWvD,EAAMqB,GAEpB,CGhG2B4G,CAAQhB,EAAM/D,MAAO7B,GAAxC6B,EAAP4E,EAAA,GAAcrB,EAAdqB,EAAA,GACMjB,EAAatD,EAAW0D,EAAML,QAASvF,GACvC6G,EAAiB9G,EAAa6F,EAAMiB,eAAgB7G,GACpD+D,EAAW7B,EAAW0D,EAAM7B,SAAU/D,GACtC0F,EAAMxD,EAAW0D,EAAMF,IAAK1F,GACzBiE,EAAmBU,KAA5B,GAEA,OAAOC,EAAMC,SACX,WAAA,MAAO,CACL2B,KAAAA,EACA3E,MAAOA,EACP,eAAmC,YAAnBgF,EAChBnB,IAAAA,EACAoB,OALKV,EAWLW,SAXKT,EAAP,GAoBA,CAACE,EAAM3E,EAAOgF,EAAgBnB,EAAKF,EAAYzB,EAAUqB,GAE5D,CAaM,SAAS4B,EACd/B,EACAjF,GAEA,IAAM4F,EAAQ7F,EAAakF,EAAWjF,GAChC6B,EAAQ9B,EAAa6F,EAAM/D,MAAO7B,GAClCuF,EAAUxF,EAAa6F,EAAML,QAASvF,GACtCiH,EAAQlH,EAAa6F,EAAMqB,MAAOjH,GAClC6G,EAAiB9G,EAAa6F,EAAMiB,eAAgB7G,GACpD8F,EAAS/F,EAAa6F,EAAME,OAAQ9F,GAE1C,OAAO4E,EAAMC,SACX,WAAA,MAAO,CACLhD,MAAOA,EACP0D,QAAAA,EACA0B,MAAAA,EACAJ,eAAAA,EACAf,OAAAA,EALF,GAOA,CAACjE,EAAO0D,EAAS0B,EAAOJ,EAAgBf,GAE3C,CA+CM,SAASoB,EACdjC,EACA1C,EACAvC,GAEA,IAAM4F,EAAQ7F,EAAakF,EAAWjF,IFxKxC,SAAyBmH,EAAQnH,GAM/B,IALA,IAK4BoH,EALtBnH,EAAeoH,GAAgCrH,GAC/CG,EAAiBC,GAAWH,GAC5BI,EAAQF,EAAeG,EACvBgH,EAaR,SAAwBnH,GACtB,IAAImH,EAAcC,GAAY3H,IAAIO,GAKlC,OAJKmH,IACHA,EAA8B,IAAIE,QAClCD,GAAY1H,IAAIM,EAAgBmH,IAE3BA,CACR,CApBqBG,CAAetH,GAC7BuH,EAAkB,GACxBC,EAAAC,EAAoBT,KAAQC,EAAAO,KAAAE,MAAA,CAAA,IAAjBC,EAAiBV,EAAAvF,MACpBlD,EAAOmJ,EAAM,GACdR,EAAYtI,IAAIL,KACnB2I,EAAYS,IAAIpJ,GAChB+I,EAAgBM,KAAKF,GAExB,CACGJ,EAAgB7E,QAClBxC,EAAK,EAAgBqH,EAExB,CEyJCO,MACmBC,IAAjB3F,EAA6B,GAAK,CAAC,CAACqD,EAAM/D,MAAOU,IACjDvC,EAEH,CAYM,SAASmI,EACdlD,EACAjF,GAEA,IAAMoD,EAAQ8C,EAAyBjB,EAAWjF,GAC5CoI,EAAUpD,EAA2BC,EAAWjF,GAChDqI,EAAQrB,EAAyB/B,EAAWjF,GAClD,OAAO4E,EAAMC,SACX,WAAA,MAAO,CAAEzB,MAAAA,EAAOgF,QAAAA,EAASC,MAAAA,EADpB,GAEL,CAACjF,EAAOgF,EAASC,GAEpB,CAKmB,SAAAC,EAACC,GAAD,OAAQA,GAAR,CAEpB,SAASC,EAAU3G,GACjB,MAAwB,iBAAVA,GAA4C,mBAAfA,EAAM4G,IAClD,CAED,SAASC,EAAOC,GACd,OACgB,OAAdA,GACqB,iBAAdA,IACoB,mBAAnBA,EAAUrJ,MACW,mBAApBqJ,EAAUzJ,MAEtB,CAWM,SAAS0J,EACdpE,EACAqE,EACA7F,GAEA,IAAK,IAAMzD,UADX,IADAyD,IAAAA,EAAiB,IAECwB,EAAQ,CACxBxB,EAAKgF,KAAKzI,GACV,IAAMqG,EAAQpB,EAAOjF,GAErB,GAAImJ,EAAO9C,IACT,GAA6B,GAAzBiD,EAAQjD,EAAO5C,GAAiB,YAC/B,GAAI8F,MAAMC,QAAQnD,GACvB,IAAK,IAAMrG,KAAOqG,EAAO,CACvB5C,EAAKgF,KAAKzI,GACV,IAAMyJ,EAAWpD,EAAMrG,GAEvB,GAAImJ,EAAOM,IACT,GAAgC,GAA5BH,EAAQG,EAAUhG,GAAiB,YAEvC4F,EAAWI,EAAUH,EAAS7F,GAGhCA,EAAKiG,KACN,KACyB,iBAAVrD,GAChBgD,EAAWhD,EAAOiD,EAAS7F,GAG7BA,EAAKiG,KACN,CACF,qOH94BKC,EAAmBC,SACnBC,EAAoB,SAACC,GAAD,QAAeA,EAAQH,EAAvB,EAEpBI,EAAwB,SAACC,GAC7B,IAAIC,EAAIC,EAC6C,OAApDA,GAAMD,EAAKD,EAAgBL,IAAmBQ,IAAsBD,EAAGE,KAAKH,EAC9E,EACKI,GAAyB,SAAzBA,EAA0BC,EAAoBC,GAClD,IAAMC,EAAqBF,EAAmBX,GAAkBc,EAC1DC,EAAqBH,EAAmBZ,GAAkBc,EAChE,OAAOD,IAAuBE,GAAsBJ,IAAuBI,GAAsBb,EAAkBW,IAAuBH,EAAuBG,EAAoBD,EACtL,EACKI,GAAwB,SAACb,GAC7B,IAAMc,EAAiB,CACrBH,EAAGX,EACHK,EAAG,MAECH,EAAkB,IAAIa,SAAQ,SAACC,GACnCF,EAAeT,EAAI,WACjBS,EAAeT,EAAI,KACnBW,KAEFhB,EAAQZ,KAAK0B,EAAeT,EAAGS,EAAeT,EAC/C,IAED,OADAH,EAAgBL,GAAoBiB,EAC7BZ,CACR,EAEKe,GAAkB,SAAC3L,GAAD,MAAU,SAAUA,CAApB,EAUlB4L,GAAc,SAACC,GAueC,SAA2BxE,EAAAtC,GAAA,IAAzB/E,EAAyB+E,EAAA,GAAnB+G,EAAmB/G,EAAA,GACnC/C,EAAY+J,OAAa,EAAQ/L,GAIvC,GAHIgC,GAAaA,EAAUgK,KAAwB,MAAjBF,OAAwB,EAASA,EAAcE,IAC/EC,OAAkB,EAAQjM,EAAMgC,EAA4B,MAAjB8J,OAAwB,EAASA,EAAcE,IAExFF,GAAkBA,EAAc7J,KAAmB,MAAbD,OAAoB,EAASA,EAAUC,GAAjF,CAGA,IAAMhC,EAAUiM,EAAWjL,IAAIjB,GACpB,MAAXC,GAA2BA,EAAQC,EAAEiM,QAArC3L,EAFC,CAGF,CAhfL,IAGI4L,EACAC,EAJEC,EAAwC,IAAIC,QAC5CL,EAA6B,IAAIK,QACjCC,EAA6B,IAAIC,IAOvC,GAHEL,EAAiC,IAAIM,IACrCL,EAA+B,IAAIK,IAEjCb,EACF,IAAA,IAA2Cc,EAA3CC,EAAA3D,EAA4B4C,KAAec,EAAAC,KAAA1D,MAAA,CAAA,IAAA2D,EAAAF,EAAAzJ,MAA/BlD,EAA+B6M,EAAA,GACnC7K,EAAY,CAChBH,EAFuCgL,EAAA,GAGvCC,EAAG,EACH7K,EAAG,EACH+J,EAAmB,IAAIS,KAGvB/J,OAAOqK,OAAO/K,GACT2J,GAAgB3L,IACnB+H,QAAQC,KACN,2EACAhI,GAINsM,EAAsBpL,IAAIlB,EAAMgC,EACjC,CAEH,IAAMgL,EAA0C,IAAIT,QA6B9CU,EAA2C,IAAIV,QAC/CW,EAA2B,SAACpK,GAChC,IAAIqK,EAAwBF,EAAyBhM,IAAI6B,GAKzD,OAJKqK,IACHA,EAAwC,IAAIV,IAC5CQ,EAAyB/L,IAAI4B,EAASqK,IAEjCA,GAEHpB,EAAe,SAAfA,EAAgBjJ,EAAS9C,GAC7B,GAAI8C,EAAS,CACX,IAAMqK,EAAwBD,EAAyBpK,GACnDd,EAAYmL,EAAsBlM,IAAIjB,GAO1C,OANKgC,IACHA,EAAY+J,EAAajJ,EAAQV,EAAGpC,KAElCmN,EAAsBjM,IAAIlB,EAAMgC,GAG7BA,CACR,CACD,OAAOsK,EAAsBrL,IAAIjB,IAE7BoN,EAAe,SAACtK,EAAS9C,EAAMgC,GAInC,GAFEU,OAAOqK,OAAO/K,GAEZc,EAC4BoK,EAAyBpK,GACjC5B,IAAIlB,EAAMgC,OAC3B,CACL,IAAM8J,EAAgBQ,EAAsBrL,IAAIjB,GAChDsM,EAAsBpL,IAAIlB,EAAMgC,GAC3BwK,EAAWnM,IAAIL,IAClBwM,EAAWtL,IAAIlB,EAAM8L,EAExB,GAEGuB,EAAyB,SAACvK,EAASwK,EAAkDC,GACzF,QAD0G,IAAnED,IAAAA,EAAuC,IAAIb,MAC7Ec,EACH,OAAOD,EAET,IAAME,EAAmC,IAAIf,IACzCgB,EAAU,EASd,OARAF,EAAapB,SAAQ,SAACnM,GACpB,IAAI6K,EACE6C,GAAkD,OAArC7C,EAAKkB,EAAajJ,EAAS9C,SAAiB,EAAS6K,EAAGiC,IAAM,EACjFU,EAAiBtM,IAAIlB,EAAM0N,GACvBJ,EAAqBrM,IAAIjB,KAAU0N,IACrCD,EAAU,MAGVH,EAAqBnN,OAASqN,EAAiBrN,MAASsN,EAGrDD,EAFEF,GAILK,EAAe,SAAC7K,EAAS9C,EAAMkD,EAAOqK,EAAc3C,GACxD,IAAM5I,EAAY+J,EAAajJ,EAAS9C,GACxC,GAAIgC,EAAW,CACb,GAAI4I,MAAsB,MAAO5I,KAAeiJ,GAAuBjJ,EAAUI,EAAGwI,IAClF,OAAO5I,EAEL,MAAOA,GACT2I,EAAsB3I,EAAUI,EAEnC,CACD,IAAMwL,EAAgB,CACpB/L,EAAGqB,EACH4J,GAAiB,MAAb9K,OAAoB,EAASA,EAAU8K,IAAM,EACjD7K,EAAG,EACH+J,EAAGqB,EAAuBvK,EAAsB,MAAbd,OAAoB,EAASA,EAAUgK,EAAGuB,IAE3EE,IAAyB,MAAbzL,OAAoB,EAASA,EAAUC,GAavD,OAZKD,GAAe,MAAOA,GAAeU,OAAOC,GAAGX,EAAUH,EAAGqB,GAMtD0K,EAAc5B,IAAMhK,EAAUgK,GAAM4B,EAAc5B,EAAE7L,OAAS6B,EAAUgK,EAAE7L,MAASgK,MAAM0D,KAAKD,EAAc5B,EAAE8B,QAAQC,OAAM,SAACC,GAAD,OAAOhM,EAAUgK,EAAE3L,IAAI2N,EAAhE,MAC3FP,EAAU,EACVhC,QAAQC,UAAU5B,MAAK,WACrBmE,EAAanL,EACd,MATD2K,EAAU,IACRG,EAAcd,EACZc,EAAc5B,EAAE3L,IAAIL,KACtB4N,EAAc5B,EAAI,IAAIS,IAAImB,EAAc5B,GAAG9K,IAAIlB,EAAM4N,EAAcd,KAQnE9K,IAAcyL,EACTzL,GAEToL,EAAatK,EAAS9C,EAAM4N,GACrBA,IAEHM,EAAmB,SAACpL,EAAS9C,EAAMmO,EAAOZ,EAAc3C,GAC5D,IAAM5I,EAAY+J,EAAajJ,EAAS9C,GACxC,GAAIgC,EAAW,CACb,GAAI4I,MAAsB,MAAO5I,KAAeiJ,GAAuBjJ,EAAUI,EAAGwI,IAClF,OAAO5I,EAEL,MAAOA,GACT2I,EAAsB3I,EAAUI,EAEnC,CACD,IAAMwL,EAAgB,CACpBzL,EAAGgM,EACHrB,IAAkB,MAAb9K,OAAoB,EAASA,EAAU8K,IAAM,GAAK,EACvD7K,EAAG,EACH+J,EAAGqB,EAAuBvK,EAAsB,MAAbd,OAAoB,EAASA,EAAUgK,EAAGuB,IAG/E,OADAH,EAAatK,EAAS9C,EAAM4N,GACrBA,GAEHQ,EAAyB,SAACtL,EAAS9C,EAAM4K,EAAiB2C,GAC9D,IAAMvL,EAAY+J,EAAajJ,EAAS9C,GACxC,GAAIgC,GAAa,MAAOA,EAAW,CACjC,GAAIiJ,GAAuBjJ,EAAUI,EAAGwI,GACtC,OAAK5I,EAAUC,EAGRD,EAFLqM,EAAAA,EAAA,CAAA,EAAYrM,GAAZ,CAAA,EAAA,CAAuBC,EAAG,IAI9B0I,EAAsB3I,EAAUI,EACjC,EArJ+B,SAACU,EAAS9C,EAAM4K,GAChD,IAAI0D,EAAQtB,EAAwB/L,IAAIjB,GACnCsO,IACHA,EAAwB,IAAI7B,IAC5BO,EAAwB9L,IAAIlB,EAAMsO,IAEpC1D,EAAgBd,MAAK,WACfwE,EAAMrN,IAAI6B,KAAa8H,IACzB0D,EAAMC,OAAOzL,GACRwL,EAAMnO,MACT6M,EAAwBuB,OAAOvO,OAIrCsO,EAAMpN,IAAI4B,EAAS8H,GAwInB4D,CAA0B1L,EAAS9C,EAAM4K,GACzC,IAAMgD,EAAgB,CACpBxL,EAAGwI,EACHkC,IAAkB,MAAb9K,OAAoB,EAASA,EAAU8K,IAAM,GAAK,EACvD7K,EAAG,EACH+J,EAAGqB,EAAuBvK,EAAsB,MAAbd,OAAoB,EAASA,EAAUgK,EAAGuB,IAG/E,OADAH,EAAatK,EAAS9C,EAAM4N,GACrBA,GAEHa,EAAwB,SAAC3L,EAAS9C,EAAM0O,EAAgBnB,GAQpC,SAAMlI,IAClBsJ,EAAc7L,EAAS9C,EAAM,EAC9B,CATX,GAAI0O,aAA0BjD,QAAS,CACrC,IAAMb,EAAkBW,GACtBmD,EAAe5E,MAAK,SAAC5G,GACnByK,EAAa7K,EAAS9C,EAAMkD,EAAOqK,EAAc3C,EAClD,IAAEgE,OAAM,SAACzM,GACR,GAAIA,aAAasJ,QACf,OAAIhB,EAAkBtI,GACbA,EAAE2H,KAATzE,GAIKlD,EAET+L,EAAiBpL,EAAS9C,EAAMmC,EAAGoL,EAAc3C,EAXnD,KAcF,OAAOwD,EACLtL,EACA9C,EACA4K,EACA2C,EAEH,CACD,OAAOI,EACL7K,EACA9C,EACA0O,EACAnB,IAeEoB,EAAgB,SAAhBA,EAAiB7L,EAAS9C,EAAM6O,GACpC,IAAKA,EAAO,CACV,IAAM7M,EAAY+J,EAAajJ,EAAS9C,GACxC,GAAIgC,EAAW,CACb,GAAIA,EAAUC,GAAK,MAAOD,IAlRQ,SAAC4I,GAAD,OAAsBA,EAAgBL,GAAkBQ,CAAxD,CAkRM+D,CAAkC9M,EAAUI,GAClF,OAAOJ,EAcT,GAZAA,EAAUgK,EAAEG,SAAQ,SAAC4C,EAAGf,GACtB,GAAIA,IAAMhO,EACR,GAAKkM,EAAW7L,IAAI2N,GAEb,CACL,IAAMgB,EAASjD,EAAajJ,EAASkL,GACjCgB,IAAWA,EAAO/M,GACpB0M,EAAc7L,EAASkL,EAE1B,MANCW,EAAc7L,EAASkL,EAQ5B,IACG7D,MAAM0D,KAAK7L,EAAUgK,GAAG+B,OAAM,SAAYkB,GAAA,IAAVjB,EAAUiB,EAAA,GAAPnC,EAAOmC,EAAA,GACtCD,EAASjD,EAAajJ,EAASkL,GACrC,OAAOgB,KAAY,MAAOA,IAAWA,EAAOlC,IAAMA,CACnD,IACC,OAAK9K,EAAUC,EAGRD,EAFLqM,EAAAA,EAAA,CAAA,EAAYrM,GAAZ,CAAA,EAAA,CAAuBC,EAAG,GAI/B,CACF,CACD,IAAMsL,EAA+B,IAAIb,IACzC,IACE,IAAMgC,EAAiB1O,EAAKW,MAAK,SAACqN,GAChCT,EAAanE,IAAI4E,GACjB,IAAMgB,EAAShB,IAAMhO,EAAO+L,EAAajJ,EAASkL,GAAKW,EAAc7L,EAASkL,GAC9E,GAAIgB,EAAQ,CACV,GAAI,MAAOA,EACT,MAAMA,EAAO7M,EAEf,GAAI,MAAO6M,EACT,MAAMA,EAAO5M,EAEf,OAAO4M,EAAOnN,CACf,CACD,GAAI8J,GAAgBqC,GAClB,OAAOA,EAAEhN,KAEX,MAAM,IAAIkB,MAAM,eACjB,IACD,OAAOuM,EAAsB3L,EAAS9C,EAAM0O,EAAgBnB,EAY7D,CAXC,MAAO2B,GACP,GAAIA,aAA0BzD,QAAS,CACrC,IAAMb,EAAkBW,GAAsB2D,GAC9C,OAAOd,EACLtL,EACA9C,EACA4K,EACA2C,EAEH,CACD,OAAOW,EAAiBpL,EAAS9C,EAAMkP,EAAgB3B,EACxD,GAaG4B,EAANC,EAOMC,EAAuB,SAAvBA,EAAwBvM,EAAS9C,GACrC,IAAMC,EAAUiM,EAAWjL,IAAIjB,GACpB,MAAXC,GAA2BA,EAAQG,EAAE+L,SAAQ,SAACmD,GACxCA,IAActP,IAhGK,SAAC8C,EAAS9C,GACnC,IAAMgC,EAAY+J,EAAajJ,EAAS9C,GACxC,GAAIgC,EAAW,CACb,IAAM4L,SACD5L,GADc,GAAA,CAEjBC,EAAG,IAELmL,EAAatK,EAAS9C,EAAM4N,EAL9B,MAOE7F,QAAQC,KAAK,+CAAgDhI,GAwF3DuP,CAAmBzM,EAASwM,GAC5BD,EAAqBvM,EAASwM,GAEjC,KAEGE,EAAiB,SAAjBA,EAAkB1M,EAAS9C,EAAMmB,GACrC,IAAIsO,EAAS,EAwDPC,EAAgB1P,EAAKO,OAvDP,SAAdoP,EAAe3B,EAAG4B,GACtB,IAAMZ,EAASL,EAAc7L,EAASkL,GACtC,GAAI,MAAOgB,EACT,MAAMA,EAAO7M,EAEf,GAAI,MAAO6M,EAAQ,CACjB,GAAe,MAAXY,OAAkB,EAASA,EAAQC,iBACrC,OAAOb,EAAO5M,EAAE0H,MACd,WAAA,OAAM6F,EAAY3B,EAAG4B,EAArB,IASJ,MALE7H,QAAQ+H,KACN,6EACA9B,GAGEgB,EAAO5M,CACd,CACD,GAAI,MAAO4M,EACT,OAAOA,EAAOnN,EAQhB,MALEkG,QAAQC,KACN,sFACAgG,GAGE,IAAI9L,MAAM,qBAEH,SAAC8L,EAAGnM,GACjB,IAAIkO,EACJ,GAAI/B,IAAMhO,EAAM,CACd,IAAK2L,GAAgBqC,GACnB,MAAM,IAAI9L,MAAM,qBAElB,IAAM8N,EA3T4B,SAAChQ,GACvC,IAAMgQ,EAA6B,IAAItD,IACjC4B,EAAQtB,EAAwB/L,IAAIjB,GAQ1C,OAPIsO,IACFtB,EAAwBuB,OAAOvO,GAC/BsO,EAAMnC,SAAQ,SAACvB,EAAiB9H,GAC9B6H,EAAsBC,GACtBoF,EAAW5G,IAAItG,EAChB,KAEIkN,EAiTgBC,CAAgCjC,GACnDgC,EAAW7D,SAAQ,SAAC+D,GACdA,IAAqBpN,GACvB2L,EAAsByB,EAAkBlC,EAAGnM,EAE9C,IACqBkK,EAAajJ,EAASkL,KACtBS,EAAsB3L,EAASkL,EAAGnM,IAEtDwN,EAAqBvM,EAASkL,EAEjC,MACC+B,EAAiBP,EAAe1M,EAASkL,EAAGnM,GAK9C,OAHK4N,GACHxB,EAAanL,GAERiN,IAE6C5O,GAEtD,OADAsO,EAAS,EACFC,GAEHS,EAAY,SAACC,EAAajP,EAAQ2B,GACtC,IAAM4M,EAAgBF,EAAe1M,EAASsN,EAAajP,GAE3D,OADA8M,EAAanL,GACN4M,GAEHW,EAAN/P,EACMgQ,EAAY,SAAZA,EAAaxN,EAAS9C,EAAMuQ,GAChC,IAAMtQ,EAAU,CACdG,EAAG,IAAIsM,IAAI6D,GAAoB,CAACA,IAChCrQ,EAAmB,IAAIwM,KAiBzB,GAfAR,EAAWhL,IAAIlB,EAAMC,GAEnBoM,EAAajD,IAAIpJ,GAED2O,OAAc,EAAQ3O,GAC9BgM,EAAEG,SAAQ,SAAC4C,EAAGf,GACtB,IAAMwC,EAAWtE,EAAWjL,IAAI+M,GAC5BwC,EACFA,EAASpQ,EAAEgJ,IAAIpJ,GAEXgO,IAAMhO,GACRsQ,EAAUxN,EAASkL,EAAGhO,MAIxBqQ,EAAuBrQ,IAASA,EAAKyQ,QAAS,CAChD,IACMC,EAAY1Q,EAAKyQ,SADP,SAACtP,GAAD,OAAYgP,EAAUnQ,EAAMmB,EAAQ2B,EAApC,IAEhBA,OAAU,EACN4N,IACFzQ,EAAQ0Q,EAAID,EAEf,CACD,OAAOzQ,GAEH2Q,EAAc,SAAdA,EAAe9N,EAAS9C,GAC5B,IAAI6K,EACE6F,EAA2C,OAA9B7F,EAAKqB,EAAWjL,IAAIjB,SAAiB,EAAS6K,EAAG8F,EAChED,GACFA,IAEFxE,EAAWqC,OAAOvO,GAEhBqM,EAAakC,OAAOvO,GAEtB,IAAMgC,EAAY+J,EAAajJ,EAAS9C,GACpCgC,EACFA,EAAUgK,EAAEG,SAAQ,SAAC4C,EAAGf,GACtB,GAAIA,IAAMhO,EAAM,CACd,IAAMC,EAAUiM,EAAWjL,IAAI+M,GAC3B/N,IACFA,EAAQG,EAAEmO,OAAOvO,GACbmP,EAAenB,EAAG/N,IACpB2Q,EAAY9N,EAASkL,GAG1B,CACF,IAEDjG,QAAQC,KAAK,6CAA8ChI,IAGzDiM,EAAoB,SAACnJ,EAAS9C,EAAMgC,EAAWsL,GACnD,IAAMC,EAAe,IAAIb,IAAI1K,EAAUgK,EAAE8B,QACjB,MAAxBR,GAAwCA,EAAqBnB,SAAQ,SAAC4C,EAAGf,GACvE,GAAIT,EAAalN,IAAI2N,GACnBT,EAAagB,OAAOP,OADtB,CAIA,IAAM/N,EAAUiM,EAAWjL,IAAI+M,GAC3B/N,IACFA,EAAQG,EAAEmO,OAAOvO,GACbmP,EAAenB,EAAG/N,IACpB2Q,EAAY9N,EAASkL,GALxB,CAQF,IACDT,EAAapB,SAAQ,SAAC6B,GACpB,IAAM/N,EAAUiM,EAAWjL,IAAI+M,GAC3B/N,EACFA,EAAQG,EAAEgJ,IAAIpJ,GACLkM,EAAW7L,IAAIL,IACxBsQ,EAAUxN,EAASkL,EAAGhO,OAItBiO,EAAe,SAACnL,GAO+B,SAAAsE,EAAC3G,GAAD,OAAcA,EAASqC,EAAvB,CANnD,GAAIA,EAC4BoK,EAAyBpK,GACjCqJ,SAAQ,SAACnK,EAAWhC,GAExC,GAAIgC,IADuBsK,EAAsBrL,IAAIjB,GACf,CACpC,IAAMC,EAAUiM,EAAWjL,IAAIjB,GACpB,MAAXC,GAA2BA,EAAQC,EAAEiM,QAArC/E,EACD,CACF,QARH,CAWA,KAAOoF,EAAWrM,MAAM,CACtB,IAAM0Q,EAAU1G,MAAM0D,KAAKrB,GAC3BA,EAAWsE,QACXD,EAAQ1E,QAAR9E,EAWD,CAEC+E,EAAeD,QAAfzL,EAjBD,GAyDD,MAAO,CACLoM,EApPa,SAACiE,EAAajO,GAE7B,OADkB6L,EAAc7L,EAASiO,IAoPvCtN,EAAc0M,EACdpF,EA5Be,SAACiG,EAAOlO,GACrBA,GAb8B,SAACA,GACLoK,EAAyBpK,GACjCqJ,SAAQ,SAACnK,EAAWhC,GACxC,IAAM8L,EAAgBQ,EAAsBrL,IAAIjB,KAC3C8L,GAAiB9J,EAAU8K,EAAIhB,EAAcgB,GAAK9K,EAAUC,IAAM6J,EAAc7J,GAAKD,EAAU8K,IAAMhB,EAAcgB,GAAK9K,EAAUgK,IAAMF,EAAcE,KACzJM,EAAsBpL,IAAIlB,EAAMgC,GAC5BA,EAAUgK,KAAwB,MAAjBF,OAAwB,EAASA,EAAcE,IAClEC,EAAkBnJ,EAAS9C,EAAMgC,EAA4B,MAAjB8J,OAAwB,EAASA,EAAcE,OAO/FiF,CAA4BnO,GAE9BmL,OAAa,IAyBXtM,EAvBkB,SAAC3B,EAAMkR,EAAUpO,GACrC,IAAM7C,EA7NQ,SAAC6C,EAASqO,GACxB,IAAIlR,EAAUiM,EAAWjL,IAAIkQ,GAI7B,OAHKlR,IACHA,EAAUqQ,EAAUxN,EAASqO,IAExBlR,EAwNSmR,CAAQtO,EAAS9C,GAC3BqR,EAAYpR,EAAQC,EAE1B,OADAmR,EAAUjI,IAAI8H,GACP,WACLG,EAAU9C,OAAO2C,GAzNL,SAACpO,EAASwO,GACxB,IAAMrR,EAAUiM,EAAWjL,IAAIqQ,GAC3BrR,GAAWkP,EAAemC,EAAcrR,IAC1C2Q,EAAY9N,EAASwO,GAuNrBC,CAAQzO,EAAS9C,KAkBjBwR,EAfiB,SAAChJ,EAAQ1F,GAC5B,IAAA,IAAoC2O,EAApCC,EAAAzI,EAA4BT,KAAQiJ,EAAAC,KAAAxI,MAAA,CAAA,IAAAyI,EAAAF,EAAAvO,MAAxBlD,EAAwB2R,EAAA,GAAlBzO,EAAkByO,EAAA,GAC9BhG,GAAgB3L,KAClByO,EAAsB3L,EAAS9C,EAAMkD,GACrCmM,EAAqBvM,EAAS9C,GAEjC,CACDiO,EAAanL,IASX8O,EAAuB,SAAC1R,GAEtB,OADAkM,EAAehD,IAAIlJ,GACZ,WACLkM,EAAemC,OAAOrO,GAEzB,EACDA,EAAyB,WAAA,OAAMmM,EAAa7D,QAAnB,EACzBwF,EAAsB,SAACA,GAAD,OAAO1B,EAAsBrL,IAAI+M,EAAjC,EACtB6D,EAAmB,SAAC7D,GAAD,OAAO9B,EAAWjL,IAAI+M,EAAtB,EAUxB,EAkCK8D,GAAuB,SAACjG,EAAekG,GAE3C,MAAO,CAAEpQ,EADKoQ,EAAuBA,EAAqBlG,GAAemG,sBAAwBpG,GAAYC,GAE9G,EACKoG,GAAkC,IAAIxF,IACtClL,GAAkB,SAACF,GAIvB,OAHK4Q,GAAgB5R,IAAIgB,IACvB4Q,GAAgB/Q,IAAIG,EAAO6Q,EAAcJ,OAEpCG,GAAgBhR,IAAII,EAC5B,EAEK8Q,GAAW,SAMXlN,GAAA,IALJmN,IAAAA,SACAvG,IAAAA,cACAxK,IAAAA,MACA0Q,IAAAA,qBACAM,IAAAA,8BAE8BC,EAAAA,EAAS,IAAhCxP,EAAPyP,EAAA,GAAgBC,EAAhBD,EAAA,GACApP,GAAU,WACR,IAAM3B,EAAiBiR,EAAkBnO,QACrC9C,EAAeiC,IACjBjC,EAAeG,EAAf,EAA8B,KAAMmB,UAC7BA,EAAQV,EACfZ,EAAeK,EAAIiB,EAEtB,GAAE,CAACA,IACJ,IAAM2P,EAAoBC,IAC1B,IAAKD,EAAkBnO,QAAS,CAC9B,IAAM9C,EAAiBsQ,GACrBjG,EACAkG,GAEF,GAAIM,EAA+B,CACjC,IAAIM,EAAW,EACfnR,EAAeiC,EAAI,SAAClD,GAClBiS,GAAW,SAACI,GACV,IAAMpQ,EAAcmQ,EAAWC,EAAgB,CAAExQ,EAAGwQ,GAEpD,OADArS,EAAMiC,GACCA,CACR,KAEHhB,EAAeK,EAAIiB,EACnBtB,EAAesL,EAAI,SAAClD,KAChB+I,EACF/I,MACE+I,EAEL,CACDF,EAAkBnO,QAAU9C,CAC7B,CACD,IAAMqR,EAAwBtR,GAAgBF,GAC9C,OAAOyR,EACLD,EAAsBV,SACtB,CACEjP,MAAOuP,EAAkBnO,SAE3B8N,EAEH,EAEGvR,GAAW,0BCxrBTiD,GAAQ0G,SA4oBR5B,GAA8B,IAAI2D,wCEuMlCvG,GAC2B,mBAAxBC,EAAMD,cACTC,EAAMD,cACN,WAAA,MAAM,CAAC,EAAP2D,EAAA,UA5wBC,SAAsBlF,GAC3B,IAAMsO,EAAiB1K,EAAkB5D,EAAMzE,KAAMyE,EAAMpD,OACrD2R,EAAwB3M,EAAoB5B,EAAMzE,KAAMyE,EAAMpD,OAGpE,OAFAkH,EAAyB9D,EAAMzE,KAAMyE,EAAMb,aAAca,EAAMpD,OAE3D,WAAYoD,EACPA,EAAMG,OAAOmO,EAAgBC,GAIpCnO,GAACJ,EAAMK,UAAP,CAAiB4E,MAAOqJ,EAAgBtJ,QAASuJ,GAEpD,SAnEM,SAA6CvO,GAClD,IAAQpD,EAAwBoD,EAAxBpD,MAAU4R,sIAAcxO,EAAhCyO,IACA,OACErO,GAACsN,GAAD,CAAU9Q,MAAOA,GACfwD,GAACL,EAAayO,GAGnB,eA6BM,SACLxO,GAEA,IAAM6B,EAAYkD,EAAa/E,EAAMzE,KAAMyE,EAAMpD,OAGjD,OAFAkH,EAAyB9D,EAAMzE,KAAMyE,EAAMb,aAAca,EAAMpD,OAE3D,WAAYoD,EACPA,EAAMG,OAAO0B,EAAU7B,MAAO6B,EAAUoD,MAAOpD,EAAUmD,SAG3D5E,GAAoBJ,EAAMK,UAAWwB,EAAU7B,MACvD,4BAkeM,SACL3D,GACkB,IAAAqS,EACZC,EAAWzP,EAAc7C,EAAO+G,MAChCwL,EAAY1P,EAAqB7C,EAAOoC,OACxCoQ,EAAc3P,EAAgC,QAAnBwP,EAACrS,EAAO8F,eAAW,IAAAuM,EAAAA,EAAA,GAC9CI,EAAYvT,GAAK,SAACiB,GACtB,OAAOA,EAAIoS,KAAevS,EAAOoC,KAClC,IACKsQ,EAAaxT,EAAe,IAE5ByT,EAAoBzT,EAAK,GACzB0T,EAAqB1T,EAA6B,SAClD2T,EAAe3T,EACnB,MACA,SAACiB,EAAKC,EAAK0G,GACT,SAAAgM,IAAA,IAAAC,EAAAC,EAAAxL,EAAApF,EAAAiE,EAAA4M,EAAAC,EAAA,OAAAC,IAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAA5R,KAAA4R,EAAAhQ,MAAA,KAAA,EAAA,GACOyD,EADP,CAAAuM,EAAAhQ,KAAA,EAAA,KAAA,CAAA,OAAAgQ,EAAAC,OAAA,UAAA,KAAA,EAAA,GAIQN,EAAM7S,EAAIwS,GAAqB,EACrCvS,EAAIuS,EAAmBK,GACjBxL,EAAQrH,EAAIsS,GACZrQ,EAAQjC,EAAIoS,GAEJ,SAAVzL,GAA8B,WAAVA,GACtB1G,EAAIoS,EAAa,GAGfnM,EAAmB,IAUnB0C,EAREkK,EAAuB,UAAAjT,EAAOsE,gBAAP,IAAAyO,OAAA,EAAAA,EAAA7I,KAAAlK,EAAkB,CAC7CG,IAAAA,EACAqH,MAAAA,EACA1B,QAAS3F,EAAIqS,GACbpQ,MAAAA,EACA0E,MAAOA,KApBX,CAAAuM,EAAAhQ,KAAA,GAAA,KAAA,CAAA,OAwBI2P,IAAQ7S,EAAIwS,IACVvS,EAAIwS,EAAoB,cAzB9BS,EAAAhQ,KAAA,GA0BoB4P,EA1BpB,KAAA,GAAA,GAAAI,EAAAE,GAAAL,EAAAG,EAAAG,KAAAH,EAAAI,GAAA,OAAAJ,EAAAE,IAAAF,EAAAI,GAAA,CAAAJ,EAAAhQ,KAAA,GAAA,KAAA,CAAAgQ,EAAAI,QAAA,IAAAP,EAAA,KAAA,GAAA,IAAAG,EAAAI,GAAA,CAAAJ,EAAAhQ,KAAA,GAAA,KAAA,CAAAgQ,EAAAK,GAAAR,EAAAG,EAAAhQ,KAAA,GAAA,MAAA,KAAA,GAAAgQ,EA0B6ClT,GAAAA,EAAIuS,GA1BjD,KAAA,GA0BIrM,EA1BJgN,EAAAK,GAAAL,EAAAhQ,KAAA,GAAA,MAAA,KAAA,GA4BIgD,EAAS4M,QAAAA,EAAwB9S,EAAIuS,GA5BzC,KAAA,GA+BMM,IAAQ7S,EAAIwS,KACdvS,EAAIsS,EAAYrM,GAChBjG,EAAIwS,EAAoBvM,EAAOjD,OAAS,EAAI,UAAY,UAjC5D,KAAA,GAAA,IAAA,MAAA,OAAAiQ,EAAAM,OAAA,GAAAb,EAAA,CAD4B,SAAAc,IAAA,OAAAA,EAAAC,EAAAV,IAAAW,KAAAhB,KAAAiB,MAAAC,KAAAC,UAAA,MAAA,IAAnBnN,IAAAA,EAAQ,QAAW,WAAA8M,EAAAG,MAAAC,KAAAC,UAAA,CAsC5BC,EACD,IAGGC,EAAUjV,EAEd,MAEIkV,EAAYlV,EAAiB,MAAM,SAACiB,EAAKC,GAC7CA,EAAIsS,EAAY,IAChBtS,EAAIoS,EAAaxP,IACjB5C,EAAImS,EAAWvP,IAGf5C,EAAIuS,EAAJrN,GACAlF,EAAIwS,EAAoB,QACzB,IAED,OAAO1T,EAAK,CACV6H,KAAMuL,EACNlQ,MAAOmQ,EACPzM,QAAS0M,EACThL,MAAOiL,EACPnO,SAAUuO,EACVzL,eAAgBwL,EAChBvM,OAAQqM,EACR1N,MAAOoP,EACPnO,IAAKkO,EACLE,kBAAmBrU,EAAOsE,SAC1BgQ,eAAgB3B,GAEnB,aAlhBM,SACL5N,GACkB,SAcHwP,EAdGC,EAAAC,EAAAC,GAAA,OAAAC,EAAAZ,MAAAC,KAAAC,UAAA,CAclB,SAAAW,EACEzU,EACAC,EACA0G,GAME,SAAA+N,EAAwB1O,GAAxB,IAAA2O,EAAAtP,EAAApD,EAAAoF,EAAAwL,EAAA+B,EAAA1O,EAAA2O,EAAA,OAAA7B,IAAAC,MAAA,SAAA6B,GAAA,OAAA,OAAAA,EAAAxT,KAAAwT,EAAA5R,MAAA,KAAA,EAAA,GACQmC,EAAYrF,EAAIgG,GAChB/D,EAAQjC,EAAIqF,EAAUpD,OACtBoF,EAAQrH,EAAIqF,EAAUgC,OAGtBwL,EAAM7S,EAAIqF,EAAU8O,gBAAkB,EAC5ClU,EAAIoF,EAAU8O,eAAgBtB,GAEhB,SAAVlM,GAA8B,WAAVA,GACtB1G,EAAIoF,EAAUM,QAAS,IAarBiD,EAVEgM,EAAe,UAAAvP,EAAU6O,yBAAV,IAAAS,OAAA,EAAAA,EAAA5K,KAAA1E,EAA8B,CACjDrF,IAAAA,EACAiC,MAAAA,EACAoF,MAAAA,EACA1B,QAAS3F,EAAIqF,EAAUM,SACvBgB,MAAAA,KAlBJ,CAAAmO,EAAA5R,KAAA,GAAA,KAAA,CAAA,OAwBIjD,EAAIoF,EAAU4B,eAAgB,cAxBlC6N,EAAA5R,KAAA,GAyBoB0R,EAzBpB,KAAA,GAAA,GAAAE,EAAA1B,GAAAyB,EAAAC,EAAAzB,KAAAyB,EAAAxB,GAAA,OAAAwB,EAAA1B,IAAA0B,EAAAxB,GAAA,CAAAwB,EAAA5R,KAAA,GAAA,KAAA,CAAA4R,EAAAxB,QAAA,IAAAuB,EAAA,KAAA,GAAA,IAAAC,EAAAxB,GAAA,CAAAwB,EAAA5R,KAAA,GAAA,KAAA,CAAA4R,EAAAvB,GAAAsB,EAAAC,EAAA5R,KAAA,GAAA,MAAA,KAAA,GAAA4R,EAAAvB,GAyBqCvT,EAAIqF,EAAUa,QAzBnD,KAAA,GAyBIA,EAzBJ4O,EAAAvB,GAAAuB,EAAA5R,KAAA,GAAA,MAAA,KAAA,GA2BIgD,EAAS0O,QAAAA,EAAgB5U,EAAIqF,EAAUa,QA3B3C,KAAA,GAAA,GA8BM2M,IAAQ7S,EAAIqF,EAAU8O,kBACxBlU,EAAIoF,EAAUa,OAAQA,GACtBjG,EACEoF,EAAU4B,eACVf,EAAOjD,OAAS,EAAI,UAAY,WAIhCiD,IAAUA,EAAOjD,OAtCvB,CAAA6R,EAAA5R,KAAA,GAAA,KAAA,CAAA,OAAA4R,EAAA3B,OAAA,SAuCW,GAvCX,KAAA,GAAA,OAAA2B,EAAA3B,OAAA,SA0CS,GA1CT,KAAA,GAAA,IAAA,MAAA,OAAA2B,EAAAtB,OAAA,GAAAkB,EAAA,CADiB,SAAA1G,EAAC+G,GAAc,SAAAC,IAAA,OAAAA,EAAAtB,EAAAV,IAAAW,KAAAe,KAAAd,MAAAC,KAAAC,UAAA,CA8ChCmB,EAAS7M,KA9CuB,SAAA8M,GAAA,OAAAF,EAAApB,MAAAC,KAAAC,UAAA,CA8ClB3P,CAAS4Q,GACxB,CAvDH,IAAAnQ,EAAAqQ,EAAA,OAAAjC,IAAAC,MAAA,SAAAkC,GAAA,OAAA,OAAAA,EAAA7T,KAAA6T,EAAAjS,MAAA,KAAA,EAAA,OAKQ0B,EAAS5E,EAAIoV,GACbH,EAA+B,GAErCjM,EAAWpE,EAAXoJ,GARFmH,EAAAjS,KAAA,EAyDQsH,QAAQ6K,IAAIJ,GAzDpB,KAAA,EAAA,IAAA,MAAA,OAAAE,EAAA3B,OAAA,GAAAiB,EAAA,CAdkB,SAAAD,IAAA,OAAAA,EAAAd,EAAAV,IAAAW,KAAAc,KAAAb,MAAAC,KAAAC,UAAA,CAClB,IAAMsB,EAAa1S,EAAckC,GAC3B0Q,EAAavW,GAAK,SAACiB,GACvB,IAAM4E,EAAS5E,EAAIoV,GACb7N,EAAS,CAAA,EAOf,OALAyB,EAAWpE,GAAQ,SAACoB,EAAO5C,GACzB,IAAMiC,EAAYrF,EAAIgG,GACtBlD,EAAQyE,EAAQnE,EAAMpD,EAAIqF,EAAUpD,OACrC,IAEMsF,CACR,IA8DKkL,EAAqB1T,GAA6B,SAACiB,GACvD,IAAM4E,EAAS5E,EAAIoV,GACfG,EAAiC,QAerC,OAbAvM,EAAWpE,GAAQ,SAACoB,GAClB,IAAMX,EAAYrF,EAAIgG,GAChBwP,EAAcxV,EAAIqF,EAAU4B,gBAElC,MAAoB,eAAhBuO,GACFD,EAAS,aACF,GACkB,YAAhBC,GACTD,EAAS,UACF,QAFF,CAIR,IAEMA,CACR,IAEK7C,EAAe3T,EACnB,MACA,SAACiB,EAAKC,EAAK0G,QAAmB,IAAnBA,IAAAA,EAAQ,QACjBA,GAASyN,EAAepU,EAAKC,EAAK0G,EACnC,IAGG4L,EAAaxT,GAAK,SAACiB,GACvB,IAAM4E,EAAS5E,EAAIoV,GACblP,EAAS,CAAA,EAOf,OALA8C,EAAWpE,GAAQ,SAACoB,EAAO5C,GACzB,IAAMiC,EAAYrF,EAAIgG,GACtBlD,EAAQoD,EAAQ9C,EAAMpD,EAAIqF,EAAUa,QACrC,IAEMA,CACR,IAEKuP,EAAkB1W,EAAK,GACvB2W,EAAwB3W,EAAK,GAC7B4W,EAAmB5W,EAA2B,QAC9C6W,EAAa7W,EAGjB,MAAM,SAACiB,EAAKC,EAAKsE,GACjB,SAAAsR,IAAA,IAAAhD,EAAAiD,EAAA,OAAA9C,IAAAC,MAAA,SAAA8C,GAAA,OAAA,OAAAA,EAAAzU,KAAAyU,EAAA7S,MAAA,KAAA,EAAA,OAGQ2P,EAAM7S,EAAI0V,GAAyB,EACzCzV,EAAIyV,EAAuB7C,GAC3B5S,EAAIwV,EAAJ3R,GALFiS,EAAA7S,KAAA,EAMQkR,EAAepU,EAAKC,EAAK,UANjC,KAAA,EAAA,GASyB,YAFAD,EAAIyS,GAP7B,CAAAsD,EAAA7S,KAAA,EAAA,KAAA,CAAA,OAAA6S,EAAA5C,OAAA,SAWMN,IAAQ7S,EAAI0V,IAA0BzV,EAAI0V,EAAkB,SAXlE,KAAA,EAAA,GAeQG,EAAavR,EAASvE,EAAIsV,IAflCS,EAAAzU,KAAA,GAkBQsH,EAAUkN,GAlBlB,CAAAC,EAAA7S,KAAA,GAAA,KAAA,CAAA,OAmBM2P,IAAQ7S,EAAI0V,IACVzV,EAAI0V,EAAkB,cApB9BI,EAAA7S,KAAA,GAqBY4S,EArBZ,KAAA,GAAAC,EAAA7S,KAAA,GAAA,MAAA,KAAA,GAAA6S,EAAAzU,KAAA,GAAAyU,EAAAzC,GAAAyC,EAAA,MAAA,GAAA,KAAA,GAAA,OAAAA,EAAAzU,KAAA,GA0BQuR,IAAQ7S,EAAI0V,IACdzV,EAAI0V,EAAkB,aA3B5BI,EAAAC,OAAA,IAAA,KAAA,GAAA,IAAA,MAAA,OAAAD,EAAAvC,OAAA,GAAAqC,EAAA,KAAA,CAAA,CAAA,EAAA,GAAA,GAAA,KAAA,CAD8B,SAAAI,IAAA,OAAAA,EAAAvC,EAAAV,IAAAW,KAAAkC,KAAAjC,MAAAC,KAAAC,UAAA,EAAA,WAAAmC,EAAArC,MAAAC,KAAAC,UAAA,CAiC9BoC,EACD,IAEK5D,EAAYvT,GAAK,SAACiB,GACtB,IAAM4E,EAAS5E,EAAIoV,GACf/N,EAAQ,EAQZ,OANA2B,EAAWpE,GAAQ,SAACoB,GAClB,IAAMX,EAAYrF,EAAIgG,GAEtB,GADAqB,EAAQrH,EAAIqF,EAAUgC,OACX,OAAO,CACnB,IAEMA,CACR,IAEK8O,EAAoBpX,GAAK,SAACiB,GAC9B,IAAM4E,EAAS5E,EAAIoV,GACbgB,EAAgB,CAAA,EAOtB,OALApN,EAAWpE,GAAQ,SAACoB,EAAO5C,GACzB,IAAMiC,EAAYrF,EAAIgG,GACtBlD,EAAQsT,EAAehT,EAAMpD,EAAIqF,EAAUM,SAC5C,IAEMyQ,CACR,IAEKnC,EAAYlV,EAAK,MAAM,SAACiB,EAAKC,GAEjC+I,EADehJ,EAAIoV,IACA,SAACpP,GAClB,IAAMX,EAAYrF,EAAIgG,GACtB/F,EAAIoF,EAAUR,MACf,IAED5E,EAAIyV,EAAJ1R,GACA/D,EAAI0V,EAAkB,OACvB,IAED,OAAO5W,EAAK,CACV6F,OAAQwQ,EACR7N,OAAQ+N,EACRpP,OAAQqM,EACRlL,MAAOiL,EACP8D,cAAeD,EACfhS,SAAUuO,EACVzL,eAAgBwL,EAChB3N,OAAQ8Q,EACRS,aAAcV,EACdW,YAAab,EACb5Q,MAAOoP,GAEV,gEAyeM,SACL5O,EACAjF,GAEA,IAAM4F,EAAQ7F,EAAakF,EAAWjF,GACtC,OAAOD,EAAa6F,EAAME,OAAQ9F,EACnC,+FAvBM,SACLiF,EACAjF,GAEA,IAAM4F,EAAQ7F,EAAakF,EAAWjF,GACtC,OAAOD,EAAa6F,EAAM/D,MAAO7B,EAClC,uCApXM,SACL6D,EACA7D,GAsBsB,SAAMmW,IACpBpS,EAAS,OACV,CAvBkB,SAoBVqS,IACTnS,EAAAkS,EAGD,CAvBL,IAAM9S,EAAOtD,EAAa8D,EAAU7D,GAC9BqW,EAAenU,EAAWmB,EAAKmB,OAAQxE,GACvCyE,EAAQvC,EAAWmB,EAAKoB,MAAOzE,GAC/B+D,EAAW7B,EAAWmB,EAAKU,SAAU/D,GACrCqE,EAAenC,EAAWmB,EAAKqB,OAAQ1E,GACvC0E,EAASE,EAAMvC,aACnB,SAAC8E,GAAD,OACE,SAACrG,GACCA,SAAAA,EAAGwD,iBACHD,EAAa8C,GAHjB,GAKA,CAAC9C,IAEMJ,EAAmBU,KAA5B,GAEA,OAAOC,EAAMC,SACX,WAAA,MAAO,CACLwR,aAAAA,EACA5R,MAAAA,EACAV,SAHKuS,EAAAF,GAQL1R,OAAAA,EATG,GAWL,CAAC2R,EAAc5R,EAAOV,EAAUW,GAEnC,sBAWM,SACLb,EACA7D,GAEA,IAAMqD,EAAOtD,EAAa8D,EAAU7D,GACpC,OAAOD,EAAasD,EAAKyC,OAAQ9F,EAClC,qBAjGM,SACL6D,EACA7D,GAEA,IAAMqD,EAAOtD,EAAa8D,EAAU7D,GAC9BuE,EAAaxE,EAAasD,EAAKmB,OAAQxE,GACvCkW,EAAcnW,EAAasD,EAAK6S,YAAalW,GAC7CiW,EAAelW,EAAasD,EAAK4S,aAAcjW,GAC/C6G,EAAiB9G,EAAasD,EAAKwD,eAAgB7G,GACnDmH,EAASpH,EAAasD,EAAK8D,OAAQnH,GACnC8F,EAAS/F,EAAasD,EAAKyC,OAAQ9F,GACnCiH,EAAQlH,EAAasD,EAAK4D,MAAOjH,GACjCgW,EAAgBjW,EAAasD,EAAK2S,cAAehW,GAEvD,OAAO4E,EAAMC,SACX,WAAA,MAAO,CACLN,WAAYA,EACZ4C,OAAQA,EACRrB,OAAQA,EACRmB,MAAAA,EACA+O,cAAeA,EACfE,YAAAA,EACAD,aAAAA,EACApP,eAAAA,EARF,GAUA,CACEtC,EACA4C,EACArB,EACAmB,EACA+O,EACAE,EACAD,EACApP,GAGL,sBA2FM,SACLhD,EACA7D,GAEA,IAAMqD,EAAOtD,EAAa8D,GACpBoS,EAAelW,EAAasD,EAAK4S,aAAcjW,GAC/C6G,EAAiB9G,EAAasD,EAAKwD,eAAgB7G,GAEzD,OAAO4E,EAAMC,SACX,WAAA,MAAO,CAAEoR,aAAAA,EAAcpP,eAAAA,EAAvB,GACA,CAACoP,EAAcpP,GAElB,sBAaM,SACLhD,EACA7D,GAEA,IAASiE,EAAmBU,KAA5B,GAEMN,EAAenC,EADRnC,EAAa8D,EAAU7D,GACC0E,OAAQ1E,GAC7C,OAAO4E,EAAMvC,aACX,SAAC8E,GAGmB,SAAMoP,IACpBlS,EAAa8C,EACd,CALL,OACE,SAACrG,GACCA,SAAAA,EAAGwD,iBACHL,EAAAsS,GAHJ,GAOA,CAAClS,GAEJ,sBA7DM,SACLR,EACA7D,GAEA,IAAMqD,EAAOtD,EAAa8D,EAAU7D,GACpC,OAAOD,EAAasD,EAAK8D,OAAQnH,EAClC"}