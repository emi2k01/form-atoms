{"version":3,"file":"index.mjs","sources":["../../src/utils.ts","../../src/index.tsx"],"sourcesContent":["export function setPath(target: any, paths: string[], value: unknown) {\n  if (paths.length === 1) {\n    target[paths[0]] = value;\n    return target;\n  }\n\n  let next = target;\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (i === paths.length - 1) {\n      next[path] = value;\n    } else {\n      const current = next[path];\n      next = next[path] = current ?? (isNaN(paths[i + 1] as any) ? {} : []);\n    }\n  }\n}\n","import type {\n  Atom,\n  ExtractAtomUpdate,\n  ExtractAtomValue,\n  Getter,\n  Setter,\n  WritableAtom,\n} from \"jotai\";\nimport { atom, Provider, useAtom, useAtomValue, useSetAtom } from \"jotai\";\nimport { atomWithReset, RESET, useHydrateAtoms } from \"jotai/utils\";\nimport * as React from \"react\";\nimport { setPath } from \"./utils\";\n\n//\n// Components\n//\n\n/**\n * A React component that renders form atoms and their fields in an isolated\n * scope using a Jotai Provider.\n *\n * @param {FormProps<Fields>} props - Component props\n */\nexport function Form<Fields extends FormAtomFields>(props: FormProps<Fields>) {\n  const { scope, ...atomProps } = props;\n  return (\n    <Provider scope={scope}>\n      <FormAtom {...atomProps} />\n    </Provider>\n  );\n}\n\nfunction FormAtom<Fields extends FormAtomFields>(\n  props:\n    | {\n        atom: FormAtom<Fields>;\n        render(props: UseFormAtom<Fields>): JSX.Element;\n      }\n    | {\n        atom: FormAtom<Fields>;\n        component: React.ComponentType<UseFormAtom<Fields>>;\n      }\n) {\n  const form = useFormAtom(props.atom);\n\n  if (\"render\" in props) {\n    return props.render(form);\n  }\n\n  return <props.component {...form} />;\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that are rendered as native HTML elements because\n * the props can unpack directly into the underlying component.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function InputField<Value extends string | number | string[]>(\n  props: InputFieldProps<Value>\n) {\n  const fieldAtom = useFieldAtom(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtom.props, fieldAtom.state, fieldAtom.actions);\n  }\n\n  return React.createElement(props.component, fieldAtom.props);\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that aren't rendered as native HTML elements.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function Field<Value>(props: FieldProps<Value>) {\n  const fieldAtomState = useFieldAtomState(props.atom, props.scope);\n  const fieldAtomStateActions = useFieldAtomActions(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtomState, fieldAtomStateActions);\n  }\n\n  return (\n    <props.component state={fieldAtomState} actions={fieldAtomStateActions} />\n  );\n}\n\n//\n// Forms\n//\n\n/**\n * An atom that derives its state fields atoms and allows you to submit,\n * validate, and reset your form.\n *\n * @param {FormAtomFields} fields - An object containing field atoms to\n *   be included in the form. Field atoms can be deeply nested in\n *   objects and arrays.\n * @returns The `formAtom` function returns a Jotai `Atom`\n *   comprised of other atoms for managing the state of the form.\n */\nexport function formAtom<Fields extends FormAtomFields>(\n  fields: Fields\n): FormAtom<Fields> {\n  const fieldsAtom = atomWithReset(fields);\n  const valuesAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const values = {} as FormAtomValues<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(values, path, get(fieldAtom.value));\n    });\n\n    return values;\n  });\n\n  async function validateFields(\n    get: Getter,\n    set: Setter,\n    event: FieldAtomValidateOn\n  ) {\n    const fields = get(fieldsAtom);\n    const promises: Promise<boolean>[] = [];\n\n    walkFields(fields, (nextField) => {\n      async function validate(field: typeof nextField) {\n        const fieldAtom = get(field);\n        const value = get(fieldAtom.value);\n        const dirty = get(fieldAtom.dirty);\n        // This pointer prevents a stale validation result from being\n        // set after the most recent validation has been performed.\n        const ptr = get(fieldAtom._validateCount) + 1;\n        set(fieldAtom._validateCount, ptr);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(fieldAtom.touched, true);\n        }\n\n        const maybePromise = fieldAtom._validateCallback?.({\n          get,\n          value,\n          dirty,\n          touched: get(fieldAtom.touched),\n          event,\n        });\n\n        let errors: string[];\n\n        if (isPromise(maybePromise)) {\n          set(fieldAtom.validateStatus, \"validating\");\n          errors = (await maybePromise) ?? get(fieldAtom.errors);\n        } else {\n          errors = maybePromise ?? get(fieldAtom.errors);\n        }\n\n        if (ptr === get(fieldAtom._validateCount)) {\n          set(fieldAtom.errors, errors);\n          set(\n            fieldAtom.validateStatus,\n            errors.length > 0 ? \"invalid\" : \"valid\"\n          );\n        }\n\n        if (errors && errors.length) {\n          return false;\n        }\n\n        return true;\n      }\n\n      promises.push(validate(nextField));\n    });\n\n    await Promise.all(promises);\n  }\n\n  const validateResultAtom = atom<FormAtomValidateStatus>((get) => {\n    const fields = get(fieldsAtom);\n    let status: FormAtomValidateStatus = \"valid\";\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      const fieldStatus = get(fieldAtom.validateStatus);\n\n      if (fieldStatus === \"validating\") {\n        status = \"validating\";\n        return false;\n      } else if (fieldStatus === \"invalid\") {\n        status = \"invalid\";\n        return false;\n      }\n    });\n\n    return status;\n  });\n\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      event && validateFields(get, set, event);\n    }\n  );\n\n  const errorsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const errors = {} as FormAtomErrors<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(errors, path, get(fieldAtom.errors));\n    });\n\n    return errors;\n  });\n\n  const submitCountAtom = atom(0);\n  const submitStatusCountAtom = atom(0);\n  const submitResultAtom = atom<FormAtomSubmitStatus>(\"idle\");\n  const submitAtom = atom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >(null, (get, set, onSubmit) => {\n    async function resolveSubmit() {\n      // This pointer prevents a stale validation result from being\n      // set after the most recent validation has been performed.\n      const ptr = get(submitStatusCountAtom) + 1;\n      set(submitStatusCountAtom, ptr);\n      set(submitCountAtom, (count) => ++count);\n      await validateFields(get, set, \"submit\");\n      const validateStatus = get(validateResultAtom);\n\n      if (validateStatus === \"invalid\") {\n        return (\n          ptr === get(submitStatusCountAtom) && set(submitResultAtom, \"idle\")\n        );\n      }\n\n      const submission = onSubmit(get(valuesAtom));\n\n      try {\n        if (isPromise(submission)) {\n          ptr === get(submitStatusCountAtom) &&\n            set(submitResultAtom, \"submitting\");\n          await submission;\n        }\n        // eslint-disable-next-line no-empty\n      } catch (err) {\n      } finally {\n        if (ptr === get(submitStatusCountAtom)) {\n          set(submitResultAtom, \"submitted\");\n        }\n      }\n    }\n\n    resolveSubmit();\n  });\n\n  const dirtyAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    let dirty = false;\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      dirty = get(fieldAtom.dirty);\n      if (dirty) return false;\n    });\n\n    return dirty;\n  });\n\n  const touchedFieldsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const touchedFields = {} as FormAtomTouchedFields<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(touchedFields, path, get(fieldAtom.touched));\n    });\n\n    return touchedFields;\n  });\n\n  const resetAtom = atom(null, (get, set) => {\n    const fields = get(fieldsAtom);\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      set(fieldAtom.reset);\n    });\n\n    set(submitStatusCountAtom, (current) => ++current);\n    set(submitResultAtom, \"idle\");\n  });\n\n  return atom({\n    fields: fieldsAtom,\n    values: valuesAtom,\n    errors: errorsAtom,\n    dirty: dirtyAtom,\n    touchedFields: touchedFieldsAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    submit: submitAtom,\n    submitStatus: submitResultAtom,\n    submitCount: submitCountAtom,\n    reset: resetAtom,\n  });\n}\n\n/**\n * A hook that returns an object that contains the `fieldAtoms` and actions to\n * validate, submit, and reset the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of functions that can be used to interact\n *   with the form.\n */\nexport function useFormAtom<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): UseFormAtom<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      reset,\n      submit(onSubmit) {\n        return (e) => {\n          e?.preventDefault();\n          startTransition(() => {\n            handleSubmit(onSubmit);\n          });\n        };\n      },\n    }),\n    [fieldAtoms, validate, reset, handleSubmit]\n  );\n}\n\n/**\n * A hook that returns the primary state of the form atom including values, errors,\n * submit and validation status, as well as the `fieldAtoms`. Note that this\n * hook will cuase its parent component to re-render any time those states\n * change, so it can be useful to use more targeted state hooks like\n * `useFormAtomStatus`.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomState<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomState<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const submitCount = useAtomValue(form.submitCount, scope);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n  const values = useAtomValue(form.values, scope);\n  const errors = useAtomValue(form.errors, scope);\n  const dirty = useAtomValue(form.dirty, scope);\n  const touchedFields = useAtomValue(form.touchedFields, scope);\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      values: values as any,\n      errors: errors as any,\n      dirty,\n      touchedFields: touchedFields as any,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    }),\n    [\n      fieldAtoms,\n      values,\n      errors,\n      dirty,\n      touchedFields,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    ]\n  );\n}\n\n/**\n * A hook that returns a set of actions that can be used to update the state\n * of the form atom. This includes updating fields, submitting, resetting,\n * and validating the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomActions<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomActions<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const updateFields = useSetAtom(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const submit = React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        handleSubmit(values);\n      },\n    [handleSubmit]\n  );\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      updateFields,\n      reset,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      submit,\n    }),\n    [updateFields, reset, validate, submit]\n  );\n}\n\n/**\n * A hook that returns the errors of the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form data.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the form.\n */\nexport function useFormAtomErrors<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.errors, scope);\n}\n\n/**\n * A hook that returns the values of the form atom\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The values of the form.\n */\nexport function useFormAtomValues<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.values, scope);\n}\n\n/**\n * A hook that returns the `submitStatus` and `validateStatus` of\n * the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns An object containing the `submitStatus` and\n *   `validateStatus` of the form\n */\nexport function useFormAtomStatus<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomStatus {\n  const form = useAtomValue(formAtom);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n\n  return React.useMemo(\n    () => ({ submitStatus, validateStatus }),\n    [submitStatus, validateStatus]\n  );\n}\n\n/**\n * A hook that returns a callback for handling form submission.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A callback for handling form submission. The callback\n *   takes the form values as an argument and returs an additional callback\n *   that invokes `event.preventDefault()` if it receives an event as its argument.\n */\nexport function useFormAtomSubmit<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const [, startTransition] = useTransition();\n  const form = useAtomValue(formAtom, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  return React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        startTransition(() => {\n          handleSubmit(values);\n        });\n      },\n    [handleSubmit]\n  );\n}\n\n//\n// Fields\n//\n\n/**\n * An atom that represents a field in a form. It manages state for the field,\n * including the name, value, errors, dirty, validation, and touched state.\n *\n * @param {FieldAtomConfig<Value>} config - The initial state and configuration of the field.\n * @returns A FieldAtom.\n */\nexport function fieldAtom<Value>(\n  config: FieldAtomConfig<Value>\n): FieldAtom<Value> {\n  const nameAtom = atomWithReset(config.name);\n  const valueAtom = atomWithReset<Value>(config.value);\n  const touchedAtom = atomWithReset(config.touched ?? false);\n  const dirtyAtom = atom((get) => {\n    return get(valueAtom) !== config.value;\n  });\n  const errorsAtom = atom<string[]>([]);\n\n  const validateCountAtom = atom(0);\n  const validateResultAtom = atom<FormAtomValidateStatus>(\"valid\");\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      async function resolveErrors() {\n        if (!event) return;\n        // This pointer prevents a stale validation result from being\n        // set to state after the most recent invocation of validate.\n        const ptr = get(validateCountAtom) + 1;\n        set(validateCountAtom, ptr);\n        const dirty = get(dirtyAtom);\n        const value = get(valueAtom);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(touchedAtom, true);\n        }\n\n        let errors: string[] = [];\n\n        const maybeValidatePromise = config.validate?.({\n          get,\n          dirty,\n          touched: get(touchedAtom),\n          value,\n          event: event,\n        });\n\n        if (isPromise(maybeValidatePromise)) {\n          ptr === get(validateCountAtom) &&\n            set(validateResultAtom, \"validating\");\n          errors = (await maybeValidatePromise) ?? get(errorsAtom);\n        } else {\n          errors = maybeValidatePromise ?? get(errorsAtom);\n        }\n\n        if (ptr === get(validateCountAtom)) {\n          set(errorsAtom, errors);\n          set(validateResultAtom, errors.length > 0 ? \"invalid\" : \"valid\");\n        }\n      }\n\n      resolveErrors();\n    }\n  );\n\n  const refAtom = atom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n  >(null);\n\n  const resetAtom = atom<null, void>(null, (get, set) => {\n    set(errorsAtom, []);\n    set(touchedAtom, RESET);\n    set(valueAtom, RESET);\n    // Need to set a new pointer to prevent stale validation results\n    // from being set to state after this invocation.\n    set(validateCountAtom, (count) => ++count);\n    set(validateResultAtom, \"valid\");\n  });\n\n  return atom({\n    name: nameAtom,\n    value: valueAtom,\n    touched: touchedAtom,\n    dirty: dirtyAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    errors: errorsAtom,\n    reset: resetAtom,\n    ref: refAtom,\n    _validateCallback: config.validate,\n    _validateCount: validateCountAtom,\n  });\n}\n\n/**\n * A hook that returns a set of actions that can be used to interact with the\n * field atom state.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of actions that can be used to interact with the field atom.\n */\nexport function useFieldAtomActions<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomActions<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const setValue = useSetAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const setErrors = useSetAtom(field.errors, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const reset = useSetAtom(field.reset, scope);\n  const ref = useAtomValue(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      setValue(value) {\n        setValue(value);\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n      setTouched(touched) {\n        setTouched(touched);\n\n        if (touched) {\n          startTransition(() => {\n            validate(\"touch\");\n          });\n        }\n      },\n      setErrors,\n      focus() {\n        ref?.focus();\n      },\n      reset,\n    }),\n    [setErrors, reset, validate, setValue, setTouched, ref]\n  );\n}\n\n/**\n * A hook that returns a set of props that can be destructured\n * directly into an `<input>`, `<select>`, or `<textarea>` element.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of props that can be destructured directly into an `<input>`,\n *   `<select>`, or `<textarea>` element.\n */\nexport function useFieldAtomProps<\n  Value\n>(fieldAtom: FieldAtom<Value>, scope?: Scope): FieldAtomProps<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const name = useAtomValue(field.name, scope);\n  const [value, setValue] = useAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const ref = useSetAtom(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      name,\n      value: value as Value,\n      \"aria-invalid\": validateStatus === \"invalid\",\n      ref,\n      onBlur() {\n        setTouched(true);\n        startTransition(() => {\n          validate(\"blur\");\n        });\n      },\n      onChange(event) {\n        // @ts-expect-error\n        setValue(event.target.value);\n\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n    }),\n    [name, value, validateStatus, ref, setTouched, validate, setValue]\n  );\n}\n\n/**\n * A hook that returns the state of a field atom. This includes the field's\n * value, whether it has been touched, whether it is dirty, the validation status,\n * and any errors.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The state of the field atom.\n */\nexport function useFieldAtomState<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomState<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const value = useAtomValue(field.value, scope);\n  const touched = useAtomValue(field.touched, scope);\n  const dirty = useAtomValue(field.dirty, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const errors = useAtomValue(field.errors, scope);\n\n  return React.useMemo(\n    () => ({\n      value: value as unknown as Value,\n      touched,\n      dirty,\n      validateStatus,\n      errors,\n    }),\n    [value, touched, dirty, validateStatus, errors]\n  );\n}\n\n/**\n * A hook that returns the value of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The value of the field atom.\n */\nexport function useFieldAtomValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.value, scope);\n}\n\n/**\n * A hook that returns the errors of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtomErrors<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.errors, scope);\n}\n\n/**\n * Sets the initial value of a field atom. Initial values can only be set once\n * per scope. Therefore, if the initial value used is changed during rerenders,\n * it won't update the atom value.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that you want to use to store the value.\n * @param {Value} initialValue - The initial value of the field.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFieldAtomInitialValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  initialValue?: Value,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  useHydrateAtoms(\n    initialValue === undefined ? [] : [[field.value, initialValue] as const],\n    scope\n  );\n}\n\n/**\n * A hook that returns `props`, `state`, and `actions` of a field atom from\n * `useFieldAtomProps`, `useFieldAtomState`, and `useFieldAtomActions`.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtom<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): UseFieldAtom<Value> {\n  const props = useFieldAtomProps<Value>(fieldAtom, scope);\n  const actions = useFieldAtomActions<Value>(fieldAtom, scope);\n  const state = useFieldAtomState<Value>(fieldAtom, scope);\n  return React.useMemo<UseFieldAtom<Value>>(\n    () => ({ props, actions, state }),\n    [props, actions, state]\n  );\n}\n\nconst useTransition: () => [boolean, typeof React.startTransition] =\n  typeof React.useTransition === \"function\"\n    ? React.useTransition\n    : () => [false, (fn) => fn()];\n\nfunction isPromise(value: any): value is Promise<any> {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n}\n\nfunction isAtom(maybeAtom: any): maybeAtom is FieldAtom<any> {\n  return (\n    maybeAtom !== null &&\n    typeof maybeAtom === \"object\" &&\n    (typeof maybeAtom.read === \"function\" ||\n      typeof maybeAtom.write === \"function\")\n  );\n}\n\n/**\n * A function that walks through an object containing nested field atoms\n * and calls a visitor function for each atom it finds.\n *\n * @param {FormAtomFields} fields - An object containing nested field atoms\n * @param visitor - A function that will be called for each field atom. You can\n *  exit early by returning `false` from the function.\n * @param path - The base path of the field atom.\n */\nexport function walkFields<Fields extends FormAtomFields>(\n  fields: Fields,\n  visitor: (field: FieldAtom<any>, path: string[]) => void | false,\n  path: string[] = []\n) {\n  for (const key in fields) {\n    path.push(key);\n    const field = fields[key];\n\n    if (isAtom(field)) {\n      if (visitor(field, path) === false) return;\n    } else if (Array.isArray(field)) {\n      for (const key in field) {\n        path.push(key);\n        const subField = field[key];\n\n        if (isAtom(subField)) {\n          if (visitor(subField, path) === false) return;\n        } else {\n          walkFields(subField, visitor, path);\n        }\n\n        path.pop();\n      }\n    } else if (typeof field === \"object\") {\n      walkFields(field, visitor, path);\n    }\n\n    path.pop();\n  }\n}\n\nexport { Provider } from \"jotai\";\n\nexport type InputFieldProps<Value extends string | number | string[]> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props that can be directly unpacked into a native HTML input element\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        props: FieldAtomProps<Value>,\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component:\n        | \"input\"\n        | \"textarea\"\n        | \"select\"\n        | React.ComponentType<FieldAtomProps<Value>>;\n    };\n\nexport type FieldProps<Value> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component: React.ComponentType<{\n        state: FieldAtomState<Value>;\n        actions: FieldAtomActions<Value>;\n      }>;\n    };\n\nexport type FormProps<Fields extends FormAtomFields> =\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props returned from a `useFormAtom` hook\n       */\n      render(props: UseFormAtom<Fields>): JSX.Element;\n    }\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component.\n       */\n      component: React.ComponentType<UseFormAtom<Fields>>;\n    };\n\n/**\n * A form submission status\n */\nexport type FormAtomSubmitStatus = \"idle\" | \"submitting\" | \"submitted\";\n/**\n * A form and field validation status\n */\nexport type FormAtomValidateStatus = \"validating\" | \"valid\" | \"invalid\";\n/**\n * Event types that a field atom may validate against\n */\nexport type FieldAtomValidateOn =\n  | \"user\"\n  | \"blur\"\n  | \"change\"\n  | \"touch\"\n  | \"submit\";\n\nexport type FieldAtom<Value> = Atom<{\n  /**\n   * An atom containing the field's name\n   */\n  name: WritableAtom<string | undefined, string | undefined | typeof RESET>;\n  /**\n   * An atom containing the field's value\n   */\n  value: WritableAtom<Value, Value | typeof RESET | ((prev: Value) => Value)>;\n  /**\n   * An atom containing the field's touched status\n   */\n  touched: WritableAtom<\n    boolean,\n    boolean | typeof RESET | ((prev: boolean) => boolean)\n  >;\n  /**\n   * An atom containing the field's dirty status\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A write-only atom for validating the field's value\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * An atom containing the field's validation status\n   */\n  validateStatus: WritableAtom<FormAtomValidateStatus, FormAtomValidateStatus>;\n  /**\n   * An atom containing the field's validation errors\n   */\n  errors: WritableAtom<string[], string[] | ((value: string[]) => string[])>;\n  /**\n   * A write-only atom for resetting the field atoms to their\n   * initial states.\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * An atom containing a reference to the `HTMLElement` the field\n   * is bound to.\n   */\n  ref: WritableAtom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null,\n    | HTMLInputElement\n    | HTMLTextAreaElement\n    | HTMLSelectElement\n    | null\n    | ((\n        value: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n      ) => HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null)\n  >;\n  _validateCount: WritableAtom<number, number | ((current: number) => number)>;\n  _validateCallback?: Validate<Value>;\n}>;\n\nexport type FormAtom<Fields extends FormAtomFields> = Atom<{\n  /**\n   * An atom containing an object of nested field atoms\n   */\n  fields: WritableAtom<\n    Fields,\n    Fields | typeof RESET | ((prev: Fields) => Fields),\n    void\n  >;\n  /**\n   * An read-only atom that derives the form's values from\n   * its nested field atoms.\n   */\n  values: Atom<FormAtomValues<Fields>>;\n  /**\n   * An read-only atom that derives the form's errors from\n   * its nested field atoms.\n   */\n  errors: Atom<FormAtomErrors<Fields>>;\n  /**\n   * A read-only atom that returns `true` if any of the fields in\n   * the form are dirty.\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A read-only atom derives the touched state of its nested field atoms.\n   */\n  touchedFields: Atom<FormAtomTouchedFields<Fields>>;\n  /**\n   * A write-only atom that resets the form's nested field atoms\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * A write-only atom that validates the form's nested field atoms\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * A read-only atom that derives the form's validation status\n   */\n  validateStatus: Atom<FormAtomValidateStatus>;\n  /**\n   * A write-only atom for submitting the form\n   */\n  submit: WritableAtom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >;\n  /**\n   * A read-only atom that reads the number of times the form has\n   * been submitted\n   */\n  submitCount: Atom<number>;\n  /**\n   * An atom that contains the form's submission status\n   */\n  submitStatus: WritableAtom<FormAtomSubmitStatus, FormAtomSubmitStatus>;\n}>;\n\n/**\n * An object containing nested field atoms\n */\nexport type FormAtomFields = {\n  [key: string | number]:\n    | FieldAtom<any>\n    | FormAtomFields\n    | FormAtomFields[]\n    | FieldAtom<any>[];\n};\n\n/**\n * An object containing the values of a form's nested field atoms\n */\nexport type FormAtomValues<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<infer Value>\n    ? Value\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\n/**\n * An object containing the errors of a form's nested field atoms\n */\nexport type FormAtomErrors<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? string[]\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomErrors<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomErrors<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport type FormAtomTouchedFields<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? boolean\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport interface UseFormAtom<Fields extends FormAtomFields> {\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface FormAtomStatus {\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomState<Fields extends FormAtomFields> {\n  /**\n   * An object containing the form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  values: FormAtomValues<Fields>;\n  /**\n   * An object containing the errors of a form's nested field atoms\n   */\n  errors: FormAtomErrors<Fields>;\n  /**\n   * `true` if any of the fields in the form are dirty.\n   */\n  dirty: boolean;\n  /**\n   * An object containing the touched state of the form's nested field atoms.\n   */\n  touchedFields: FormAtomTouchedFields<Fields>;\n  /**\n   * The number of times a form has been submitted\n   */\n  submitCount: number;\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomActions<Fields extends FormAtomFields> {\n  /**\n   * A function for adding/removing fields from the form.\n   *\n   * @param fields - An object containing the form's nested field atoms or\n   *   a callback that receives the current fields and returns the next\n   *   fields.\n   */\n  updateFields(\n    fields: ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"fields\"]>\n  ): void;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface UseFieldAtom<Value> {\n  /**\n   * `<input>`, `<select>`, or `<textarea>` props for the field\n   */\n  props: FieldAtomProps<Value>;\n  /**\n   * Actions for managing the state of the field\n   */\n  actions: FieldAtomActions<Value>;\n  /**\n   * The current state of the field\n   */\n  state: FieldAtomState<Value>;\n}\n\nexport interface FieldAtomProps<Value> {\n  /**\n   * The name of the field if there is one\n   */\n  name: string | undefined;\n  /**\n   * The value of the field\n   */\n  value: Value;\n  /**\n   * A WAI-ARIA property that tells a screen reader whether the\n   * field is invalid\n   */\n  \"aria-invalid\": boolean;\n  /**\n   * A React callback ref that is used to bind the field atom to\n   * an `<input>`, `<select>`, or `<textarea>` element so that it\n   * can be read and focused.\n   */\n  ref: React.RefCallback<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n  >;\n  onBlur(event: React.FormEvent<HTMLInputElement>): void;\n  onBlur(event: React.FormEvent<HTMLTextAreaElement>): void;\n  onBlur(event: React.FormEvent<HTMLSelectElement>): void;\n  onChange(event: React.ChangeEvent<HTMLInputElement>): void;\n  onChange(event: React.ChangeEvent<HTMLTextAreaElement>): void;\n  onChange(event: React.ChangeEvent<HTMLSelectElement>): void;\n}\n\nexport interface FieldAtomActions<Value> {\n  /**\n   * A function that validates the field's value with a `\"user\"` validation\n   * event.\n   */\n  validate(): void;\n  /**\n   * A function for changing the value of a field. This will trigger a `\"change\"`\n   * validation event.\n   *\n   * @param {Value} value - The new value of the field\n   */\n  setValue(\n    value: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>\n  ): void;\n  /**\n   * A function for changing the touched state of a field. This will trigger a\n   * `\"touch\"` validation event.\n   *\n   * @param {boolean} touched - The new touched state of the field\n   */\n  setTouched(\n    touched: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>\n  ): void;\n  /**\n   * A function for changing the error state of a field\n   *\n   * @param {string[]} errors - The new error state of the field\n   */\n  setErrors(\n    errors: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>\n  ): void;\n  /**\n   * Focuses the field atom's `<input>`, `<select>`, or `<textarea>` element\n   * if there is one bound to it.\n   */\n  focus(): void;\n  /**\n   * Resets the field atom to its initial state.\n   */\n  reset(): void;\n}\n\nexport interface FieldAtomState<Value> {\n  /**\n   * The value of the field\n   */\n  value: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>;\n  /**\n   * The touched state of the field\n   */\n  touched: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>;\n  /**\n   * The dirty state of the field. A field is \"dirty\" if it's value has\n   * been changed.\n   */\n  dirty: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"dirty\"]>;\n  /**\n   * The validation status of the field\n   */\n  validateStatus: ExtractAtomValue<\n    ExtractAtomValue<FieldAtom<Value>>[\"validateStatus\"]\n  >;\n  /**\n   * The error state of the field\n   */\n  errors: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>;\n}\n\nexport interface FieldAtomConfig<Value> {\n  /**\n   * Optionally provide a name for the field that will be added\n   * to any attached `<input>`, `<select>`, or `<textarea>` elements\n   */\n  name?: string;\n  /**\n   * The initial value of the field\n   */\n  value: Value;\n  /**\n   * The initial touched state of the field\n   */\n  touched?: boolean;\n  /**\n   * A function that validates the value of the field any time\n   * one of its atoms changes. It must either return an array of\n   * string error messages or undefined. If it returns undefined,\n   * the validation is \"skipped\" and the current errors in state\n   * are retained.\n   */\n  validate?: (state: {\n    /**\n     * A Jotai getter that can read other atoms\n     */\n    get: Getter;\n    /**\n     * The current value of the field\n     */\n    value: Value;\n    /**\n     * The dirty state of the field\n     */\n    dirty: boolean;\n    /**\n     * The touched state of the field\n     */\n    touched: boolean;\n    /**\n     * The event that caused the validation. Either:\n     *\n     * - `\"change\"` - The value of the field has changed\n     * - `\"touch\"` - The field has been touched\n     * - `\"blur\"` - The field has been blurred\n     * - `\"submit\"` - The form has been submitted\n     * - `\"user\"` - A user/developer has triggered the validation\n     */\n    event: FieldAtomValidateOn;\n  }) => void | string[] | Promise<void | string[]>;\n}\n\n/**\n * A utility type for easily typing validate functions\n */\nexport type Validate<Value> = FieldAtomConfig<Value>[\"validate\"];\n\n/**\n * A utility type for easily typing validate function configurations\n */\nexport type ValidateConfig<Value> = Parameters<\n  Exclude<FieldAtomConfig<Value>[\"validate\"], undefined>\n>[0];\n\n/**\n * A `Provider` or `useAtom` hook accepts an optional prop scope which you\n * can use for scoped Provider. When using atoms with a scope, the provider\n * with the same scope will be used. The recommendation for the scope value\n * is a unique symbol. The primary use case of scope is for library usage.\n */\nexport type Scope = symbol | string | number;\n"],"names":["setPath","target","paths","value","length","next","i","path","current","isNaN","Form","props","scope","atomProps","_excluded","__reactCreateElement__","Provider","FormAtom","form","useFormAtom","atom","render","component","_extends","InputField","fieldAtom","useFieldAtom","useFieldAtomInitialValue","initialValue","state","actions","Field","fieldAtomState","useFieldAtomState","fieldAtomStateActions","useFieldAtomActions","_ref3","count","_ref5","formAtom","fields","validateFields","_x","_x2","_x3","_validateFields","apply","this","arguments","_ref2","get","set","event","_ref","field","_fieldAtom$_validateC","dirty","ptr","_validateCount","touched","errors","_yield$maybePromise","maybePromise","_validateCallback","call","isPromise","validateStatus","fieldsAtom","promises","walkFields","nextField","_validate","_asyncToGenerator","push","_x4","validate","Promise","all","atomWithReset","valuesAtom","values","validateResultAtom","status","fieldStatus","validateAtom","errorsAtom","submitCountAtom","submitStatusCountAtom","submitResultAtom","submitAtom","onSubmit","_ref4","submission","err","_resolveSubmit","resolveSubmit","dirtyAtom","touchedFieldsAtom","touchedFields","resetAtom","reset","submit","submitStatus","submitCount","_ref6","useAtomValue","fieldAtoms","useSetAtom","handleSubmit","startTransition","useTransition","React","useMemo","_ref7","e","preventDefault","useFormAtomState","useFormAtomActions","_ref8","updateFields","useCallback","useFormAtomErrors","useFormAtomValues","useFormAtomStatus","useFormAtomSubmit","_ref10","config","_config$touched","nameAtom","name","valueAtom","touchedAtom","validateCountAtom","_ref9","_config$validate","_yield$maybeValidateP","maybeValidatePromise","_resolveErrors","resolveErrors","refAtom","RESET","ref","_ref11","_ref12","_ref13","setValue","setTouched","setErrors","focus","useFieldAtomProps","_ref14","_ref15","useAtom","onBlur","onChange","useFieldAtomValue","useFieldAtomErrors","useHydrateAtoms","undefined","_ref16","fn","then","isAtom","maybeAtom","read","write","visitor","key","Array","isArray","subField","pop"],"mappings":"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"}