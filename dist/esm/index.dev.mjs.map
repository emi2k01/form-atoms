{"version":3,"file":"index.dev.mjs","sources":["../../src/utils.ts","../../src/index.tsx"],"sourcesContent":["export function setPath(target: any, paths: string[], value: unknown) {\n  if (paths.length === 1) {\n    target[paths[0]] = value;\n    return target;\n  }\n\n  let next = target;\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (i === paths.length - 1) {\n      next[path] = value;\n    } else {\n      const current = next[path];\n      next = next[path] = current ?? (isNaN(paths[i + 1] as any) ? {} : []);\n    }\n  }\n}\n","import type {\n  Atom,\n  ExtractAtomUpdate,\n  ExtractAtomValue,\n  Getter,\n  Setter,\n  WritableAtom,\n} from \"jotai\";\nimport { atom, Provider, useAtom, useAtomValue, useSetAtom } from \"jotai\";\nimport { atomWithReset, RESET, useHydrateAtoms } from \"jotai/utils\";\nimport * as React from \"react\";\nimport { setPath } from \"./utils\";\n\n//\n// Components\n//\n\n/**\n * A React component that renders form atoms and their fields in an isolated\n * scope using a Jotai Provider.\n *\n * @param {FormProps<Fields>} props - Component props\n */\nexport function Form<Fields extends FormAtomFields>(props: FormProps<Fields>) {\n  const { scope, ...atomProps } = props;\n  return (\n    <Provider scope={scope}>\n      <FormAtom {...atomProps} />\n    </Provider>\n  );\n}\n\nfunction FormAtom<Fields extends FormAtomFields>(\n  props:\n    | {\n        atom: FormAtom<Fields>;\n        render(props: UseFormAtom<Fields>): JSX.Element;\n      }\n    | {\n        atom: FormAtom<Fields>;\n        component: React.ComponentType<UseFormAtom<Fields>>;\n      }\n) {\n  const form = useFormAtom(props.atom);\n\n  if (\"render\" in props) {\n    return props.render(form);\n  }\n\n  return <props.component {...form} />;\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that are rendered as native HTML elements because\n * the props can unpack directly into the underlying component.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function InputField<Value extends string | number | string[]>(\n  props: InputFieldProps<Value>\n) {\n  const fieldAtom = useFieldAtom(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtom.props, fieldAtom.state, fieldAtom.actions);\n  }\n\n  return React.createElement(props.component, fieldAtom.props);\n}\n\n/**\n * A React component that renders field atoms with initial values. This is\n * most useful for fields that aren't rendered as native HTML elements.\n *\n * @param {FieldProps<Value>} props - Component props\n */\nexport function Field<Value>(props: FieldProps<Value>) {\n  const fieldAtomState = useFieldAtomState(props.atom, props.scope);\n  const fieldAtomStateActions = useFieldAtomActions(props.atom, props.scope);\n  useFieldAtomInitialValue(props.atom, props.initialValue, props.scope);\n\n  if (\"render\" in props) {\n    return props.render(fieldAtomState, fieldAtomStateActions);\n  }\n\n  return (\n    <props.component state={fieldAtomState} actions={fieldAtomStateActions} />\n  );\n}\n\n//\n// Forms\n//\n\n/**\n * An atom that derives its state fields atoms and allows you to submit,\n * validate, and reset your form.\n *\n * @param {FormAtomFields} fields - An object containing field atoms to\n *   be included in the form. Field atoms can be deeply nested in\n *   objects and arrays.\n * @returns The `formAtom` function returns a Jotai `Atom`\n *   comprised of other atoms for managing the state of the form.\n */\nexport function formAtom<Fields extends FormAtomFields>(\n  fields: Fields\n): FormAtom<Fields> {\n  const fieldsAtom = atomWithReset(fields);\n  const valuesAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const values = {} as FormAtomValues<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(values, path, get(fieldAtom.value));\n    });\n\n    return values;\n  });\n\n  async function validateFields(\n    get: Getter,\n    set: Setter,\n    event: FieldAtomValidateOn\n  ) {\n    const fields = get(fieldsAtom);\n    const promises: Promise<boolean>[] = [];\n\n    walkFields(fields, (nextField) => {\n      async function validate(field: typeof nextField) {\n        const fieldAtom = get(field);\n        const value = get(fieldAtom.value);\n        const dirty = get(fieldAtom.dirty);\n        // This pointer prevents a stale validation result from being\n        // set after the most recent validation has been performed.\n        const ptr = get(fieldAtom._validateCount) + 1;\n        set(fieldAtom._validateCount, ptr);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(fieldAtom.touched, true);\n        }\n\n        const maybePromise = fieldAtom._validateCallback?.({\n          get,\n          value,\n          dirty,\n          touched: get(fieldAtom.touched),\n          event,\n        });\n\n        let errors: string[];\n\n        if (isPromise(maybePromise)) {\n          set(fieldAtom.validateStatus, \"validating\");\n          errors = (await maybePromise) ?? get(fieldAtom.errors);\n        } else {\n          errors = maybePromise ?? get(fieldAtom.errors);\n        }\n\n        if (ptr === get(fieldAtom._validateCount)) {\n          set(fieldAtom.errors, errors);\n          set(\n            fieldAtom.validateStatus,\n            errors.length > 0 ? \"invalid\" : \"valid\"\n          );\n        }\n\n        if (errors && errors.length) {\n          return false;\n        }\n\n        return true;\n      }\n\n      promises.push(validate(nextField));\n    });\n\n    await Promise.all(promises);\n  }\n\n  const validateResultAtom = atom<FormAtomValidateStatus>((get) => {\n    const fields = get(fieldsAtom);\n    let status: FormAtomValidateStatus = \"valid\";\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      const fieldStatus = get(fieldAtom.validateStatus);\n\n      if (fieldStatus === \"validating\") {\n        status = \"validating\";\n        return false;\n      } else if (fieldStatus === \"invalid\") {\n        status = \"invalid\";\n        return false;\n      }\n    });\n\n    return status;\n  });\n\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      event && validateFields(get, set, event);\n    }\n  );\n\n  const errorsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const errors = {} as FormAtomErrors<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(errors, path, get(fieldAtom.errors));\n    });\n\n    return errors;\n  });\n\n  const submitCountAtom = atom(0);\n  const submitStatusCountAtom = atom(0);\n  const submitResultAtom = atom<FormAtomSubmitStatus>(\"idle\");\n  const submitAtom = atom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >(null, (get, set, onSubmit) => {\n    async function resolveSubmit() {\n      // This pointer prevents a stale validation result from being\n      // set after the most recent validation has been performed.\n      const ptr = get(submitStatusCountAtom) + 1;\n      set(submitStatusCountAtom, ptr);\n      set(submitCountAtom, (count) => ++count);\n      await validateFields(get, set, \"submit\");\n      const validateStatus = get(validateResultAtom);\n\n      if (validateStatus === \"invalid\") {\n        return (\n          ptr === get(submitStatusCountAtom) && set(submitResultAtom, \"idle\")\n        );\n      }\n\n      const submission = onSubmit(get(valuesAtom));\n\n      try {\n        if (isPromise(submission)) {\n          ptr === get(submitStatusCountAtom) &&\n            set(submitResultAtom, \"submitting\");\n          await submission;\n        }\n        // eslint-disable-next-line no-empty\n      } catch (err) {\n      } finally {\n        if (ptr === get(submitStatusCountAtom)) {\n          set(submitResultAtom, \"submitted\");\n        }\n      }\n    }\n\n    resolveSubmit();\n  });\n\n  const dirtyAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    let dirty = false;\n\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      dirty = get(fieldAtom.dirty);\n      if (dirty) return false;\n    });\n\n    return dirty;\n  });\n\n  const touchedFieldsAtom = atom((get) => {\n    const fields = get(fieldsAtom);\n    const touchedFields = {} as FormAtomTouchedFields<Fields>;\n\n    walkFields(fields, (field, path) => {\n      const fieldAtom = get(field);\n      setPath(touchedFields, path, get(fieldAtom.touched));\n    });\n\n    return touchedFields;\n  });\n\n  const resetAtom = atom(null, (get, set) => {\n    const fields = get(fieldsAtom);\n    walkFields(fields, (field) => {\n      const fieldAtom = get(field);\n      set(fieldAtom.reset);\n    });\n\n    set(submitStatusCountAtom, (current) => ++current);\n    set(submitResultAtom, \"idle\");\n  });\n\n  return atom({\n    fields: fieldsAtom,\n    values: valuesAtom,\n    errors: errorsAtom,\n    dirty: dirtyAtom,\n    touchedFields: touchedFieldsAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    submit: submitAtom,\n    submitStatus: submitResultAtom,\n    submitCount: submitCountAtom,\n    reset: resetAtom,\n  });\n}\n\n/**\n * A hook that returns an object that contains the `fieldAtoms` and actions to\n * validate, submit, and reset the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of functions that can be used to interact\n *   with the form.\n */\nexport function useFormAtom<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): UseFormAtom<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      reset,\n      submit(onSubmit) {\n        return (e) => {\n          e?.preventDefault();\n          startTransition(() => {\n            handleSubmit(onSubmit);\n          });\n        };\n      },\n    }),\n    [fieldAtoms, validate, reset, handleSubmit]\n  );\n}\n\n/**\n * A hook that returns the primary state of the form atom including values, errors,\n * submit and validation status, as well as the `fieldAtoms`. Note that this\n * hook will cuase its parent component to re-render any time those states\n * change, so it can be useful to use more targeted state hooks like\n * `useFormAtomStatus`.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomState<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomState<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const fieldAtoms = useAtomValue(form.fields, scope);\n  const submitCount = useAtomValue(form.submitCount, scope);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n  const values = useAtomValue(form.values, scope);\n  const errors = useAtomValue(form.errors, scope);\n  const dirty = useAtomValue(form.dirty, scope);\n  const touchedFields = useAtomValue(form.touchedFields, scope);\n\n  return React.useMemo(\n    () => ({\n      fieldAtoms: fieldAtoms as Fields,\n      values: values as any,\n      errors: errors as any,\n      dirty,\n      touchedFields: touchedFields as any,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    }),\n    [\n      fieldAtoms,\n      values,\n      errors,\n      dirty,\n      touchedFields,\n      submitCount,\n      submitStatus,\n      validateStatus,\n    ]\n  );\n}\n\n/**\n * A hook that returns a set of actions that can be used to update the state\n * of the form atom. This includes updating fields, submitting, resetting,\n * and validating the form.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFormAtomActions<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomActions<Fields> {\n  const form = useAtomValue(formAtom, scope);\n  const updateFields = useSetAtom(form.fields, scope);\n  const reset = useSetAtom(form.reset, scope);\n  const validate = useSetAtom(form.validate, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  const submit = React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        handleSubmit(values);\n      },\n    [handleSubmit]\n  );\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      updateFields,\n      reset,\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      submit,\n    }),\n    [updateFields, reset, validate, submit]\n  );\n}\n\n/**\n * A hook that returns the errors of the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form data.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the form.\n */\nexport function useFormAtomErrors<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.errors, scope);\n}\n\n/**\n * A hook that returns the values of the form atom\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The values of the form.\n */\nexport function useFormAtomValues<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const form = useAtomValue(formAtom, scope);\n  return useAtomValue(form.values, scope);\n}\n\n/**\n * A hook that returns the `submitStatus` and `validateStatus` of\n * the form atom.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns An object containing the `submitStatus` and\n *   `validateStatus` of the form\n */\nexport function useFormAtomStatus<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n): FormAtomStatus {\n  const form = useAtomValue(formAtom);\n  const submitStatus = useAtomValue(form.submitStatus, scope);\n  const validateStatus = useAtomValue(form.validateStatus, scope);\n\n  return React.useMemo(\n    () => ({ submitStatus, validateStatus }),\n    [submitStatus, validateStatus]\n  );\n}\n\n/**\n * A hook that returns a callback for handling form submission.\n *\n * @param {FormAtom<FormAtomFields>} formAtom - The atom that stores the form state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A callback for handling form submission. The callback\n *   takes the form values as an argument and returs an additional callback\n *   that invokes `event.preventDefault()` if it receives an event as its argument.\n */\nexport function useFormAtomSubmit<Fields extends FormAtomFields>(\n  formAtom: FormAtom<Fields>,\n  scope?: Scope\n) {\n  const [, startTransition] = useTransition();\n  const form = useAtomValue(formAtom, scope);\n  const handleSubmit = useSetAtom(form.submit, scope);\n  return React.useCallback(\n    (values: Parameters<typeof handleSubmit>[0]) =>\n      (e?: React.FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        startTransition(() => {\n          handleSubmit(values);\n        });\n      },\n    [handleSubmit]\n  );\n}\n\n//\n// Fields\n//\n\n/**\n * An atom that represents a field in a form. It manages state for the field,\n * including the name, value, errors, dirty, validation, and touched state.\n *\n * @param {FieldAtomConfig<Value>} config - The initial state and configuration of the field.\n * @returns A FieldAtom.\n */\nexport function fieldAtom<Value>(\n  config: FieldAtomConfig<Value>\n): FieldAtom<Value> {\n  const nameAtom = atomWithReset(config.name);\n  const valueAtom = atomWithReset<Value>(config.value);\n  const touchedAtom = atomWithReset(config.touched ?? false);\n  const dirtyAtom = atom((get) => {\n    return get(valueAtom) !== config.value;\n  });\n  const errorsAtom = atom<string[]>([]);\n\n  const validateCountAtom = atom(0);\n  const validateResultAtom = atom<FormAtomValidateStatus>(\"valid\");\n  const validateAtom = atom<null, void | FieldAtomValidateOn>(\n    null,\n    (get, set, event = \"user\") => {\n      async function resolveErrors() {\n        if (!event) return;\n        // This pointer prevents a stale validation result from being\n        // set to state after the most recent invocation of validate.\n        const ptr = get(validateCountAtom) + 1;\n        set(validateCountAtom, ptr);\n        const dirty = get(dirtyAtom);\n        const value = get(valueAtom);\n\n        if (event === \"user\" || event === \"submit\") {\n          set(touchedAtom, true);\n        }\n\n        let errors: string[] = [];\n\n        const maybeValidatePromise = config.validate?.({\n          get,\n          dirty,\n          touched: get(touchedAtom),\n          value,\n          event: event,\n        });\n\n        if (isPromise(maybeValidatePromise)) {\n          ptr === get(validateCountAtom) &&\n            set(validateResultAtom, \"validating\");\n          errors = (await maybeValidatePromise) ?? get(errorsAtom);\n        } else {\n          errors = maybeValidatePromise ?? get(errorsAtom);\n        }\n\n        if (ptr === get(validateCountAtom)) {\n          set(errorsAtom, errors);\n          set(validateResultAtom, errors.length > 0 ? \"invalid\" : \"valid\");\n        }\n      }\n\n      resolveErrors();\n    }\n  );\n\n  const refAtom = atom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n  >(null);\n\n  const resetAtom = atom<null, void>(null, (get, set) => {\n    set(errorsAtom, []);\n    set(touchedAtom, RESET);\n    set(valueAtom, RESET);\n    // Need to set a new pointer to prevent stale validation results\n    // from being set to state after this invocation.\n    set(validateCountAtom, (count) => ++count);\n    set(validateResultAtom, \"valid\");\n  });\n\n  return atom({\n    name: nameAtom,\n    value: valueAtom,\n    touched: touchedAtom,\n    dirty: dirtyAtom,\n    validate: validateAtom,\n    validateStatus: validateResultAtom,\n    errors: errorsAtom,\n    reset: resetAtom,\n    ref: refAtom,\n    _validateCallback: config.validate,\n    _validateCount: validateCountAtom,\n  });\n}\n\n/**\n * A hook that returns a set of actions that can be used to interact with the\n * field atom state.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of actions that can be used to interact with the field atom.\n */\nexport function useFieldAtomActions<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomActions<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const setValue = useSetAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const setErrors = useSetAtom(field.errors, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const reset = useSetAtom(field.reset, scope);\n  const ref = useAtomValue(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      validate() {\n        startTransition(() => {\n          validate(\"user\");\n        });\n      },\n      setValue(value) {\n        setValue(value);\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n      setTouched(touched) {\n        setTouched(touched);\n\n        if (touched) {\n          startTransition(() => {\n            validate(\"touch\");\n          });\n        }\n      },\n      setErrors,\n      focus() {\n        ref?.focus();\n      },\n      reset,\n    }),\n    [setErrors, reset, validate, setValue, setTouched, ref]\n  );\n}\n\n/**\n * A hook that returns a set of props that can be destructured\n * directly into an `<input>`, `<select>`, or `<textarea>` element.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns A set of props that can be destructured directly into an `<input>`,\n *   `<select>`, or `<textarea>` element.\n */\nexport function useFieldAtomProps<\n  Value\n>(fieldAtom: FieldAtom<Value>, scope?: Scope): FieldAtomProps<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const name = useAtomValue(field.name, scope);\n  const [value, setValue] = useAtom(field.value, scope);\n  const setTouched = useSetAtom(field.touched, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const validate = useSetAtom(field.validate, scope);\n  const ref = useSetAtom(field.ref, scope);\n  const [, startTransition] = useTransition();\n\n  return React.useMemo(\n    () => ({\n      name,\n      value: value as Value,\n      \"aria-invalid\": validateStatus === \"invalid\",\n      ref,\n      onBlur() {\n        setTouched(true);\n        startTransition(() => {\n          validate(\"blur\");\n        });\n      },\n      onChange(event) {\n        // @ts-expect-error\n        setValue(event.target.value);\n\n        startTransition(() => {\n          validate(\"change\");\n        });\n      },\n    }),\n    [name, value, validateStatus, ref, setTouched, validate, setValue]\n  );\n}\n\n/**\n * A hook that returns the state of a field atom. This includes the field's\n * value, whether it has been touched, whether it is dirty, the validation status,\n * and any errors.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The state of the field atom.\n */\nexport function useFieldAtomState<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): FieldAtomState<Value> {\n  const field = useAtomValue(fieldAtom, scope);\n  const value = useAtomValue(field.value, scope);\n  const touched = useAtomValue(field.touched, scope);\n  const dirty = useAtomValue(field.dirty, scope);\n  const validateStatus = useAtomValue(field.validateStatus, scope);\n  const errors = useAtomValue(field.errors, scope);\n\n  return React.useMemo(\n    () => ({\n      value: value as unknown as Value,\n      touched,\n      dirty,\n      validateStatus,\n      errors,\n    }),\n    [value, touched, dirty, validateStatus, errors]\n  );\n}\n\n/**\n * A hook that returns the value of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The value of the field atom.\n */\nexport function useFieldAtomValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.value, scope);\n}\n\n/**\n * A hook that returns the errors of a field atom.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtomErrors<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  return useAtomValue(field.errors, scope);\n}\n\n/**\n * Sets the initial value of a field atom. Initial values can only be set once\n * per scope. Therefore, if the initial value used is changed during rerenders,\n * it won't update the atom value.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that you want to use to store the value.\n * @param {Value} initialValue - The initial value of the field.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n */\nexport function useFieldAtomInitialValue<Value>(\n  fieldAtom: FieldAtom<Value>,\n  initialValue?: Value,\n  scope?: Scope\n) {\n  const field = useAtomValue(fieldAtom, scope);\n  useHydrateAtoms(\n    initialValue === undefined ? [] : [[field.value, initialValue] as const],\n    scope\n  );\n}\n\n/**\n * A hook that returns `props`, `state`, and `actions` of a field atom from\n * `useFieldAtomProps`, `useFieldAtomState`, and `useFieldAtomActions`.\n *\n * @param {FieldAtom<any>} fieldAtom - The atom that stores the field's state.\n * @param {Scope} scope - When using atoms with a scope, the provider with\n *   the same scope will be used. The recommendation for the scope value is\n *   a unique symbol. The primary use case of scope is for library usage.\n * @returns The errors of the field atom.\n */\nexport function useFieldAtom<Value>(\n  fieldAtom: FieldAtom<Value>,\n  scope?: Scope\n): UseFieldAtom<Value> {\n  const props = useFieldAtomProps<Value>(fieldAtom, scope);\n  const actions = useFieldAtomActions<Value>(fieldAtom, scope);\n  const state = useFieldAtomState<Value>(fieldAtom, scope);\n  return React.useMemo<UseFieldAtom<Value>>(\n    () => ({ props, actions, state }),\n    [props, actions, state]\n  );\n}\n\nconst useTransition: () => [boolean, typeof React.startTransition] =\n  typeof React.useTransition === \"function\"\n    ? React.useTransition\n    : () => [false, (fn) => fn()];\n\nfunction isPromise(value: any): value is Promise<any> {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n}\n\nfunction isAtom(maybeAtom: any): maybeAtom is FieldAtom<any> {\n  return (\n    maybeAtom !== null &&\n    typeof maybeAtom === \"object\" &&\n    (typeof maybeAtom.read === \"function\" ||\n      typeof maybeAtom.write === \"function\")\n  );\n}\n\n/**\n * A function that walks through an object containing nested field atoms\n * and calls a visitor function for each atom it finds.\n *\n * @param {FormAtomFields} fields - An object containing nested field atoms\n * @param visitor - A function that will be called for each field atom. You can\n *  exit early by returning `false` from the function.\n * @param path - The base path of the field atom.\n */\nexport function walkFields<Fields extends FormAtomFields>(\n  fields: Fields,\n  visitor: (field: FieldAtom<any>, path: string[]) => void | false,\n  path: string[] = []\n) {\n  for (const key in fields) {\n    path.push(key);\n    const field = fields[key];\n\n    if (isAtom(field)) {\n      if (visitor(field, path) === false) return;\n    } else if (Array.isArray(field)) {\n      for (const key in field) {\n        path.push(key);\n        const subField = field[key];\n\n        if (isAtom(subField)) {\n          if (visitor(subField, path) === false) return;\n        } else {\n          walkFields(subField, visitor, path);\n        }\n\n        path.pop();\n      }\n    } else if (typeof field === \"object\") {\n      walkFields(field, visitor, path);\n    }\n\n    path.pop();\n  }\n}\n\nexport { Provider } from \"jotai\";\n\nexport type InputFieldProps<Value extends string | number | string[]> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props that can be directly unpacked into a native HTML input element\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        props: FieldAtomProps<Value>,\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component:\n        | \"input\"\n        | \"textarea\"\n        | \"select\"\n        | React.ComponentType<FieldAtomProps<Value>>;\n    };\n\nexport type FieldProps<Value> =\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param state - The state of the field atom\n       * @param actions - The actions of the field atom\n       */\n      render(\n        state: FieldAtomState<Value>,\n        actions: FieldAtomActions<Value>\n      ): JSX.Element;\n    }\n  | {\n      /**\n       * A field atom\n       */\n      atom: FieldAtom<Value>;\n      /**\n       * The initial value of the field\n       */\n      initialValue?: Value;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component\n       */\n      component: React.ComponentType<{\n        state: FieldAtomState<Value>;\n        actions: FieldAtomActions<Value>;\n      }>;\n    };\n\nexport type FormProps<Fields extends FormAtomFields> =\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A render prop\n       *\n       * @param props - Props returned from a `useFormAtom` hook\n       */\n      render(props: UseFormAtom<Fields>): JSX.Element;\n    }\n  | {\n      /**\n       * A form atom\n       */\n      atom: FormAtom<Fields>;\n      /**\n       * When using atoms with a scope, the provider with the same scope will be used.\n       * The recommendation for the scope value is a unique symbol. The primary use case\n       * of scope is for library usage.\n       */\n      scope?: Scope;\n      /**\n       * A React component.\n       */\n      component: React.ComponentType<UseFormAtom<Fields>>;\n    };\n\n/**\n * A form submission status\n */\nexport type FormAtomSubmitStatus = \"idle\" | \"submitting\" | \"submitted\";\n/**\n * A form and field validation status\n */\nexport type FormAtomValidateStatus = \"validating\" | \"valid\" | \"invalid\";\n/**\n * Event types that a field atom may validate against\n */\nexport type FieldAtomValidateOn =\n  | \"user\"\n  | \"blur\"\n  | \"change\"\n  | \"touch\"\n  | \"submit\";\n\nexport type FieldAtom<Value> = Atom<{\n  /**\n   * An atom containing the field's name\n   */\n  name: WritableAtom<string | undefined, string | undefined | typeof RESET>;\n  /**\n   * An atom containing the field's value\n   */\n  value: WritableAtom<Value, Value | typeof RESET | ((prev: Value) => Value)>;\n  /**\n   * An atom containing the field's touched status\n   */\n  touched: WritableAtom<\n    boolean,\n    boolean | typeof RESET | ((prev: boolean) => boolean)\n  >;\n  /**\n   * An atom containing the field's dirty status\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A write-only atom for validating the field's value\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * An atom containing the field's validation status\n   */\n  validateStatus: WritableAtom<FormAtomValidateStatus, FormAtomValidateStatus>;\n  /**\n   * An atom containing the field's validation errors\n   */\n  errors: WritableAtom<string[], string[] | ((value: string[]) => string[])>;\n  /**\n   * A write-only atom for resetting the field atoms to their\n   * initial states.\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * An atom containing a reference to the `HTMLElement` the field\n   * is bound to.\n   */\n  ref: WritableAtom<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null,\n    | HTMLInputElement\n    | HTMLTextAreaElement\n    | HTMLSelectElement\n    | null\n    | ((\n        value: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null\n      ) => HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null)\n  >;\n  _validateCount: WritableAtom<number, number | ((current: number) => number)>;\n  _validateCallback?: Validate<Value>;\n}>;\n\nexport type FormAtom<Fields extends FormAtomFields> = Atom<{\n  /**\n   * An atom containing an object of nested field atoms\n   */\n  fields: WritableAtom<\n    Fields,\n    Fields | typeof RESET | ((prev: Fields) => Fields),\n    void\n  >;\n  /**\n   * An read-only atom that derives the form's values from\n   * its nested field atoms.\n   */\n  values: Atom<FormAtomValues<Fields>>;\n  /**\n   * An read-only atom that derives the form's errors from\n   * its nested field atoms.\n   */\n  errors: Atom<FormAtomErrors<Fields>>;\n  /**\n   * A read-only atom that returns `true` if any of the fields in\n   * the form are dirty.\n   */\n  dirty: Atom<boolean>;\n  /**\n   * A read-only atom derives the touched state of its nested field atoms.\n   */\n  touchedFields: Atom<FormAtomTouchedFields<Fields>>;\n  /**\n   * A write-only atom that resets the form's nested field atoms\n   */\n  reset: WritableAtom<null, void>;\n  /**\n   * A write-only atom that validates the form's nested field atoms\n   */\n  validate: WritableAtom<null, void | FieldAtomValidateOn>;\n  /**\n   * A read-only atom that derives the form's validation status\n   */\n  validateStatus: Atom<FormAtomValidateStatus>;\n  /**\n   * A write-only atom for submitting the form\n   */\n  submit: WritableAtom<\n    null,\n    (values: FormAtomValues<Fields>) => void | Promise<void>\n  >;\n  /**\n   * A read-only atom that reads the number of times the form has\n   * been submitted\n   */\n  submitCount: Atom<number>;\n  /**\n   * An atom that contains the form's submission status\n   */\n  submitStatus: WritableAtom<FormAtomSubmitStatus, FormAtomSubmitStatus>;\n}>;\n\n/**\n * An object containing nested field atoms\n */\nexport type FormAtomFields = {\n  [key: string | number]:\n    | FieldAtom<any>\n    | FormAtomFields\n    | FormAtomFields[]\n    | FieldAtom<any>[];\n};\n\n/**\n * An object containing the values of a form's nested field atoms\n */\nexport type FormAtomValues<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<infer Value>\n    ? Value\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\n/**\n * An object containing the errors of a form's nested field atoms\n */\nexport type FormAtomErrors<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? string[]\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomErrors<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomErrors<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport type FormAtomTouchedFields<Fields extends FormAtomFields> = {\n  [Key in keyof Fields]: Fields[Key] extends FieldAtom<any>\n    ? boolean\n    : Fields[Key] extends FormAtomFields\n    ? FormAtomValues<Fields[Key]>\n    : Fields[Key] extends any[]\n    ? FormAtomValues<{\n        [Index in Extract<keyof Fields[Key], number>]: Fields[Key][Index];\n      }>\n    : never;\n};\n\nexport interface UseFormAtom<Fields extends FormAtomFields> {\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface FormAtomStatus {\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomState<Fields extends FormAtomFields> {\n  /**\n   * An object containing the form's nested field atoms\n   */\n  fieldAtoms: Fields;\n  /**\n   * An object containing the values of a form's nested field atoms\n   */\n  values: FormAtomValues<Fields>;\n  /**\n   * An object containing the errors of a form's nested field atoms\n   */\n  errors: FormAtomErrors<Fields>;\n  /**\n   * `true` if any of the fields in the form are dirty.\n   */\n  dirty: boolean;\n  /**\n   * An object containing the touched state of the form's nested field atoms.\n   */\n  touchedFields: FormAtomTouchedFields<Fields>;\n  /**\n   * The number of times a form has been submitted\n   */\n  submitCount: number;\n  /**\n   * The validation status of the form\n   */\n  validateStatus: FormAtomValidateStatus;\n  /**\n   * The submission status of the form\n   */\n  submitStatus: FormAtomSubmitStatus;\n}\n\nexport interface FormAtomActions<Fields extends FormAtomFields> {\n  /**\n   * A function for adding/removing fields from the form.\n   *\n   * @param fields - An object containing the form's nested field atoms or\n   *   a callback that receives the current fields and returns the next\n   *   fields.\n   */\n  updateFields(\n    fields: ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"fields\"]>\n  ): void;\n  /**\n   * A function for handling form submissions.\n   *\n   * @param handleSubmit - A function that is called with the form's values\n   *   when the form is submitted\n   */\n  submit(\n    handleSubmit: (\n      values: Parameters<\n        ExtractAtomUpdate<ExtractAtomValue<FormAtom<Fields>>[\"submit\"]>\n      >[0]\n    ) => void | Promise<void>\n  ): (e?: React.FormEvent<HTMLFormElement>) => void;\n  /**\n   * A function that validates the form's nested field atoms with a\n   * `\"user\"` validation event.\n   */\n  validate(): void;\n  /**\n   * A function that resets the form's nested field atoms to their\n   * initial states.\n   */\n  reset(): void;\n}\n\nexport interface UseFieldAtom<Value> {\n  /**\n   * `<input>`, `<select>`, or `<textarea>` props for the field\n   */\n  props: FieldAtomProps<Value>;\n  /**\n   * Actions for managing the state of the field\n   */\n  actions: FieldAtomActions<Value>;\n  /**\n   * The current state of the field\n   */\n  state: FieldAtomState<Value>;\n}\n\nexport interface FieldAtomProps<Value> {\n  /**\n   * The name of the field if there is one\n   */\n  name: string | undefined;\n  /**\n   * The value of the field\n   */\n  value: Value;\n  /**\n   * A WAI-ARIA property that tells a screen reader whether the\n   * field is invalid\n   */\n  \"aria-invalid\": boolean;\n  /**\n   * A React callback ref that is used to bind the field atom to\n   * an `<input>`, `<select>`, or `<textarea>` element so that it\n   * can be read and focused.\n   */\n  ref: React.RefCallback<\n    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n  >;\n  onBlur(event: React.FormEvent<HTMLInputElement>): void;\n  onBlur(event: React.FormEvent<HTMLTextAreaElement>): void;\n  onBlur(event: React.FormEvent<HTMLSelectElement>): void;\n  onChange(event: React.ChangeEvent<HTMLInputElement>): void;\n  onChange(event: React.ChangeEvent<HTMLTextAreaElement>): void;\n  onChange(event: React.ChangeEvent<HTMLSelectElement>): void;\n}\n\nexport interface FieldAtomActions<Value> {\n  /**\n   * A function that validates the field's value with a `\"user\"` validation\n   * event.\n   */\n  validate(): void;\n  /**\n   * A function for changing the value of a field. This will trigger a `\"change\"`\n   * validation event.\n   *\n   * @param {Value} value - The new value of the field\n   */\n  setValue(\n    value: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>\n  ): void;\n  /**\n   * A function for changing the touched state of a field. This will trigger a\n   * `\"touch\"` validation event.\n   *\n   * @param {boolean} touched - The new touched state of the field\n   */\n  setTouched(\n    touched: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>\n  ): void;\n  /**\n   * A function for changing the error state of a field\n   *\n   * @param {string[]} errors - The new error state of the field\n   */\n  setErrors(\n    errors: ExtractAtomUpdate<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>\n  ): void;\n  /**\n   * Focuses the field atom's `<input>`, `<select>`, or `<textarea>` element\n   * if there is one bound to it.\n   */\n  focus(): void;\n  /**\n   * Resets the field atom to its initial state.\n   */\n  reset(): void;\n}\n\nexport interface FieldAtomState<Value> {\n  /**\n   * The value of the field\n   */\n  value: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"value\"]>;\n  /**\n   * The touched state of the field\n   */\n  touched: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"touched\"]>;\n  /**\n   * The dirty state of the field. A field is \"dirty\" if it's value has\n   * been changed.\n   */\n  dirty: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"dirty\"]>;\n  /**\n   * The validation status of the field\n   */\n  validateStatus: ExtractAtomValue<\n    ExtractAtomValue<FieldAtom<Value>>[\"validateStatus\"]\n  >;\n  /**\n   * The error state of the field\n   */\n  errors: ExtractAtomValue<ExtractAtomValue<FieldAtom<Value>>[\"errors\"]>;\n}\n\nexport interface FieldAtomConfig<Value> {\n  /**\n   * Optionally provide a name for the field that will be added\n   * to any attached `<input>`, `<select>`, or `<textarea>` elements\n   */\n  name?: string;\n  /**\n   * The initial value of the field\n   */\n  value: Value;\n  /**\n   * The initial touched state of the field\n   */\n  touched?: boolean;\n  /**\n   * A function that validates the value of the field any time\n   * one of its atoms changes. It must either return an array of\n   * string error messages or undefined. If it returns undefined,\n   * the validation is \"skipped\" and the current errors in state\n   * are retained.\n   */\n  validate?: (state: {\n    /**\n     * A Jotai getter that can read other atoms\n     */\n    get: Getter;\n    /**\n     * The current value of the field\n     */\n    value: Value;\n    /**\n     * The dirty state of the field\n     */\n    dirty: boolean;\n    /**\n     * The touched state of the field\n     */\n    touched: boolean;\n    /**\n     * The event that caused the validation. Either:\n     *\n     * - `\"change\"` - The value of the field has changed\n     * - `\"touch\"` - The field has been touched\n     * - `\"blur\"` - The field has been blurred\n     * - `\"submit\"` - The form has been submitted\n     * - `\"user\"` - A user/developer has triggered the validation\n     */\n    event: FieldAtomValidateOn;\n  }) => void | string[] | Promise<void | string[]>;\n}\n\n/**\n * A utility type for easily typing validate functions\n */\nexport type Validate<Value> = FieldAtomConfig<Value>[\"validate\"];\n\n/**\n * A utility type for easily typing validate function configurations\n */\nexport type ValidateConfig<Value> = Parameters<\n  Exclude<FieldAtomConfig<Value>[\"validate\"], undefined>\n>[0];\n\n/**\n * A `Provider` or `useAtom` hook accepts an optional prop scope which you\n * can use for scoped Provider. When using atoms with a scope, the provider\n * with the same scope will be used. The recommendation for the scope value\n * is a unique symbol. The primary use case of scope is for library usage.\n */\nexport type Scope = symbol | string | number;\n"],"names":["setPath","target","paths","value","length","next","i","path","current","isNaN","Form","props","scope","atomProps","FormAtom","form","useFormAtom","atom","render","InputField","fieldAtom","useFieldAtom","useFieldAtomInitialValue","initialValue","state","actions","component","Field","fieldAtomState","useFieldAtomState","fieldAtomStateActions","useFieldAtomActions","count","formAtom","fields","fieldsAtom","atomWithReset","valuesAtom","get","values","walkFields","field","validateFields","set","event","promises","dirty","ptr","_validateCount","touched","maybePromise","_validateCallback","errors","isPromise","validateStatus","nextField","validate","push","Promise","all","validateResultAtom","status","fieldStatus","validateAtom","errorsAtom","submitCountAtom","submitStatusCountAtom","submitResultAtom","submitAtom","onSubmit","resolveSubmit","submission","err","dirtyAtom","touchedFieldsAtom","touchedFields","resetAtom","reset","submit","submitStatus","submitCount","useAtomValue","fieldAtoms","useSetAtom","handleSubmit","startTransition","useTransition","React","useMemo","e","preventDefault","useFormAtomState","useFormAtomActions","updateFields","useCallback","useFormAtomErrors","useFormAtomValues","useFormAtomStatus","useFormAtomSubmit","config","nameAtom","name","valueAtom","touchedAtom","validateCountAtom","resolveErrors","maybeValidatePromise","refAtom","RESET","ref","setValue","setTouched","setErrors","focus","useFieldAtomProps","useAtom","onBlur","onChange","useFieldAtomValue","useFieldAtomErrors","useHydrateAtoms","undefined","fn","then","isAtom","maybeAtom","read","write","visitor","key","Array","isArray","subField","pop"],"mappings":"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"}